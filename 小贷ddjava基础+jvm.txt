文件描述符：是应用程序与内核交互的接口,它为应用程序提供了访问文件资源的抽象。 	

动态代理：运行期间动态创建某个接口的实例

JVM为每个加载的类创建了对应的class实例来保存类的所有信息（储存在方法区）

通过class实例获取类信息（类本身特征）的方法称之为反射

类实现多个接口（手机既要有录音功能，也要有播放功能）具有多个功能

垃圾回收器线程





# java基础

**什么是多态**：(是什么，解决了什么问题，怎么实现)

1.允许不同的对象对同一个方法做出不同的响应，即使用统一的接口操作不同的对象

2.代码复用（通用的接口处理不同的对象），可扩展（添加新类型，只需要保证实现同样的接口），接口统一（客户端不需要关注具体类型），只需要知道接口的定义

3.继承实现（子类对象被当作父类对象调用）接口实现（声明类型是接口，实际调用是实现类）

**对象创建过程**

对象实例储存在堆内存中，变量保存对象的引用，也就是堆内存中的地址
TreeNode node1 = new TreeNode(3);
1.在堆内存中分配空间-----2.调用构造函数初始化对象-----3.将新对象的引用返回给变量

区分基本类型和引用类型，基本类型是持有一个值

**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。

**类加载过程是怎么样的？**

编译生成class字节码文件，类加载器加载到jvm，验证class内容是否合理，为类变量在方法区分配内存，得到指针交给类，初始化静态变量静态代码块

**抽象类和接口的区别？**

相同点：都不能直接实例化，需要继承和实现，单继承和多实现，多实现间接实现多继承

不同点：接口：抽象方法，不能有实现，可以有deafult，成员变量只能是public static final（静态常量）（静态的，属于类，多实例共享）（不可被修改，必须初始化）

抽象类：可以有方法定义和方法实现，可以有实例变量（对象的属性）和静态变量（类的属性），一般是基类，供其他类继承和扩展使用，不能用final修饰（必须要继承）

负载均衡接口定义了一个select方法，abstractBalance实现了这个接口，又定义了一个doselect抽象方法，select会调用doselect，randomBalance继承了抽象类，隐式继承了select方法，重写了doselect方法

**hashtable和hashmap区别是什么？**

hashtable线程安全，所有方法都加了synchornize，同一时刻只能由一个线程操控该对象，所以效率比较低

**HashMap和CurrentHashMap的区别**

current线程安全，使用了分段锁，一次只锁需要操作的那一部分

**HashMap底层怎么实现的 ？线程安全吗？**

HashMap底层是基于数组和链表实现的。HashMap将key通过hash算法映射到数组中，然后在对应的链表中查找value。当多个key的hash值相同时，会在同一个数组位置上使用链表来存储这些key-value。但是，当链表长度太长时，会影响HashMap的性能，因此在JDK1.8中，当链表长度超过阈值时，会将链表转换为红黑树，以提高查找效率。

HashMap不是线程安全的，因为多个线程同时访问HashMap时可能会导致数据不一致的问题。可以使用ConcurrentHashMap来实现线程安全的Map。（1.put涉及到计算哈希值，计算位置，完成插入等多个操作，不是原子操作2.扩容涉及到重算哈希值，重算位置，复制等 步骤，可能多线程同时扩容3.链表转红黑树是非原子的4.读写冲突，一个线程put一个线程get）

**红黑树是什么？**

二叉查找树可能退化成链表，严格的平衡树插入删除的过程可能涉及到复杂的树的变化，影响查找效率

红黑树是自平衡的二叉查找树，增删改查效率稳定olgn，满足1.根节点黑色，叶节点黑色2.红节点的两个子节点是黑色3.任意节点到叶节点的路径包含相同数目的黑色节点

补：红黑树主要用于在内存中维护有序的动态集合（epoll），而B树和B+树主要用于实现外存储的索引结构，例如数据库和文件系统。

**List和Set的区别？**有序无序，可否存放重复元素

list按插入顺序保存，需要保持元素顺序，会储存重复数据，通过索引值直接访问、插入或删除元素，适用于需要频繁进行这些操作的场景用list

不关心顺序，需要去重，快速判断元素是否存在，需要交并补等集合运算用set

**List的实现类**

ArrayList、Vector、LinkedList、stack

1. ArrayList：基于动态数组实现，优势在于支持随机访问和快速插入/删除元素，适用于频繁读取和遍历的场景。
2. LinkedList：基于双向链表实现，优势在于支持快速插入/删除元素，适用于频繁插入/删除元素的场景。
3. Vector：和ArrayList类似，但由于其线程安全性，适用于多线程环境。
4. Stack：基于Vector实现，是一个后进先出（LIFO）的数据结构，适用于需要按照后进先出顺序处理元素的场景。

**在并发编程时，在需要加锁时，不加锁会有什么问题？**

静态问题和数据不一致，可以从mysql那考虑

**线程池创建的几个参数**

1.核心线程数2.最大线程数3.等待时间4.时间单位5.任务队列6.线程工厂7.拒绝策略

**线程实现类（线程池）**

FixedThreadPool：核心线程数等于最大线程数，线程池中有空闲线程就立即执行，没有就放到任务队类，适合任务执行时间较短的情况

CachedThreadPool：线程数可以无限增大，同时闲置时对线程回收（从缓存中移除），即线程池中的线程数不是固定不变，任务队列不储存任务，只负责中转，所以效率比较高，适合任务执行时间较短、任务数不确定

SingleThreadExecutor：使用唯一的线程取执行任务，保证任务按提交顺序依次执行

ScheduledThreadPool：可以设置定期的执行任务，比如每隔 10 秒钟执行一次任务

SingleThreadScheduledExecutor：只有一个线程，定期的执行任务

**volatile关键字作用，具体怎么做到可见性？**

volatile关键字是Java中用来修饰变量的关键字，它的作用是保证变量的可见性和禁止指令重排序。

通过使用内存屏障的机制来实现可见性。内存屏障会强制刷新缓存并保证读写操作的顺序性，从而保证变量的可见性。

当一个线程对volatile变量进行写操作时，会在写操作之后插入写屏障，将最新的值刷新到主内存中。当其他线程对该变量进行读操作时，会在读操作之前插入读屏障，从主内存中获取最新的值。

**lambda(parameters) -> expression**

**什么是公平锁和非公平锁？**

公平锁按申请锁顺序获取锁，先到先得，能避免线程饥饿，但是需要维护线程队列，效率会更低一些

非公平锁按随机顺序获得锁，都可以竞争，可能导致线程饿死

**ThreadLocal 是什么？**

线程所持有的一个独立的变量副本，多线程互不干扰，有泛型，操作：get，save，remove

消息队列;

保序性，处理重复消息，可靠性，阻塞读取，是否支持消费者组

quickList和listPack

一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。

# jvm

**为什么要了解？**如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务
当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节

**需了解** 内存模型各部分作用,保存哪些数据. 

类加载双亲委派加载机制,常用加载器分别加载哪种类型的类. 

GC分代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景

**JVM内存模型（运行时数据区）：**

线程独占：程序计数器、虚拟机栈，本地方法栈， 线程共享：堆，方法区

**程序计数器**（下一条要执行的指令的地址）：字节码的行号指示器，用于选取下一条要执行的字节码指令，实现顺序，分支，循环，异常处理等操作，没有oom

补：native方法：本地机器代码实现的计算机程序方法（常指c++），而非高级程序语言，用以提高性能与底层系统交互

**虚拟机栈**（函数上下文，局部变量）：为虚拟机执行 Java 方法 （也就是字节码）服务

**本地方法栈**（和虚拟机栈一样，但是为本地方法服务）则为虚拟机使用到的 Native 方法服务

可能出现`StackOverFlow`栈内存不允许动态扩展，请求深度超过栈最大深度，或`oom`，可以动态扩展，扩展时无法申请足够的内存空间

**堆**（储存对象实例）：jdk1.7之后默认开启逃逸分析，如果某方法的对象引用没有被返回或被外面使用，可以直接在栈上分配内存

是垃圾收集器的主要管理区域，因此也叫gc堆，通常被分为新生代（eden、from survivor、to survivor）（1/3堆内存），老生代（2/3），元空间（直接内存区域），

**方法区**：储存已被虚拟机加载的**类的加载信息，常量池，静态变量，方法字节码**（字符串常量池在堆空间，运行时常量池在方法区，方法区元空间实现）

**补：堆：**

多数情况下，对象在eden区分配，没有足够空间时，发起一次Minor GC，内存不够时通过 **分配担保机制** 把新生代的对象提前转移到老年代中去

大对象（需要大量连续内存空间的对象，如：字符串、数组）直接进入老年代

**JVM异常问题？**

StackOverflowError（线程请求栈深度超过虚拟机所允许的最大深度）

OutOfMemoryError（堆内存不够用）（1.花很长时间执行垃圾回收只能回收很少的堆内存 2.创建新对象时，堆空间不足以存放新对象）

PermGen space（方法区内存不够用）

**怎么找到需要回收的垃圾？**死亡对象判断方法

一个对象没有任何引用指向它，他就会被回收，这个过程由JVM的垃圾回收器自动完成。

引用计数器，可达性分析算法（从GC Roots对象开始，通过一系列的引用链来遍历所有的对象，如果一个对象不可达，则说明它已经死亡，可以被回收了）

**垃圾回收算法有哪些？**

标记清除法、标记整理法、复制算法、分代收集算法

1.会产生大量不连续的空间碎片

2.把所有存活的向一端移动，清理调边界以外的

3.分半区，浪费空间

4.新生代使用复制算法（每次大批对象死去，只有少量存活，复制成本低）

老年代使用标记清除算法或者标记整理算法

**有哪些常见的垃圾回收器，举几个说说？**

Serial收集器，ParNew（**Parallel并行**）CMS（Concurrent Mark Sweep）收集器，G1 收集器

1. Serial收集器：单线程的垃圾回收器，使用标记-复制算法，适合小型应用程序或客户端应用程序。
2. Parallel收集器：多线程的垃圾回收器，使用标记-复制算法，适合在后台运行的中型应用程序。
3. CMS收集器：并发垃圾回收器，使用标记-清除算法，适合对响应时间有要求的中型应用程序。
4. G1收集器：并发垃圾回收器，使用标记-整理算法，适合对响应时间有要求且堆内存较大的应用程序。

其中，Serial收集器和Parallel收集器是新生代收集器，CMS和G1是老年代收集器。
