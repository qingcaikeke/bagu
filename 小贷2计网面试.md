**1）五层模型、七层模型各层模型的名字、原理；常用的部件和协议**

应用，表示，会话，传输，网络，数据链路，物理

应用，**传输，网络**，网络接口

**应用**：确定通信的性质，给应用程序或者说用户提供一个统一的接口

​			dns，http，HTTPS，dhcp，ftp，smtp

**表示**：解决用户信息的**语法表示**问题，确保一个系统的应用层发送的数据能被另一个系统的应用层识别，

​			如数据转换，压缩加密，解密。

​			**序列化和反序列化**：对象变为二进制字节流，用于网络传输或存数据库存文件

**会话**：建立、管理和终止表示层实体之间的通信会话，如服务器验证**用户登录**

​			给消息进行编号，并处理确认应答，全双工保持两个方向的数据独立性（rpc，socket）

内核：

**传输**（mss段）：不同主机上**进程**间的数据**通信**，TCP/udp

**网络**（mtu包）：通过**IP寻址**来建立两台**主机**之间的**连接**，远程定位，路由选择，实现非同一子网间的数据传输

网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的**（ip，icmp）**

**数据链路**（帧）：用**MAC**地址访问媒介，增加检验去除mac头，判断是否是发给自己这个物理地址的（arp）

**物理**：物理设备（网卡网线），光电信号和数字信号间的转化，帧头帧尾，判断是否因噪声等问题导致信号失真

补：链路层的传输能力，会动态变化，受网络环境硬件能力影响

补：（dhcp：动态获取ip地址，dhcp服务器统一分配和管理IP地址）



**补：三张表：路由表，arp缓存表，mac地址表**

以太网是实现局域网的有线网络技术。最常见的局域网即是以太网,通过交换机/集线器连接

同一以太网通过交换机直接发。判断是否同一子网，不是则发给默认网关（路由器的ip地址），arp表查路由器的

mac，送到路由器，路由器查路由表，判断要到达目标ip要从哪一端口出去，找到了目标子网后，arp查目标机器

的mac地址，送到交换机，查mac地址表，判断从交换机的哪个端口传输**（不知道数据包下一跳发给谁就发给默**

**认网关）**

**补1**：`ICMP` 用于告知网络包传送过程中**产生的错误以及各种控制信息**

**补2**：收到数据存到网卡ringbuffer，触发中断（先硬后软），中断处理函数拿出一个帧交给协议栈，协议栈先看是否是给自己的（ip，mac）

是的话到传输层，传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。

**补3**：发送网络数据的时候，涉及几次内存拷贝操作？

1.内存区数据拷贝到socket的缓冲区2.TCP发送为了重传会拷贝（传输层到网络层时）3.**ip层发现大于mtu会分片**，涉及到拷贝。其他均通过指针实现 

socket的接收缓冲区是一个指针,指向这个共享ring buffer

**？**内核缓冲区=pagecache=磁盘高速缓存，在内存里，缓存了最近被访问的数据；

**说说一个数据怎么在网络各层分割报文的**

应用层数据包，传输层TCP段，ip包，mac帧

**TCP在应用层的应用，udp在应用层的应用呢？ DNS是TCP上层协议吗？**

TCP：HTTP、HTTPS、FTP、SMTP。

udp：DNS（域名系统解析）、DHCP（动态分配ip地址和配置信息）、实时音视频传输

补：为什么dns是udp：为了快速响应，同时udp头部较小，占用网络资源更少，适合dns这种频繁短小的数据交换，可以容忍丢包，实际上dns因为可以使用缓存，不能正常工作的概率低

补：DHCP 交互中，全程都是使用 UDP 广播通信。流程：dhcp发现，提供，请求

**数据链路层有哪些协议？ARP协议的过程？**

ARP 是借助 **ARP 请求与 ARP 响应**两种类型的包确定 MAC 地址的，主机广播发送ARP请求，里面包含目标主机的ip，所有设备同时收到，如果有某台主机发现与自己的ip相同，就把自己的MAC地址放到ARP响应包发送回去

**补：广播和多播**

广播：本地广播直接广播（不转发） 	多播：**将包发送给特定组内的所有主机**（最后一排上来做题）

由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播

### HTTP

**http的特点是什么？**

基于文本，易于阅读和调试，但相比二进制效率低

灵活可扩展，可传输html，json等，可通过扩展头部支持新的功能

无状态，请求之间相互独立，服务器不会保存之前的信息，需要通过cookie，session等储存状态

#### **浏览器输入一个URL的全过程**

（dns解析，三次握手，tls四次握手，生成请求，响应，解析渲染，断连）

解析url（服务器名称，文件路径），生成http请求，dns真实地址查询（浏览器缓存，操作系统**缓存**，host文件，本地dns，权威dns，根dns）

浏览器调用socket库，创建sock，connect，委托内核协议栈工作（TCP、ip（icmp，arp）），网卡驱动，物理硬件网卡。服务器处理回复，页面渲染

解析渲染：解出对象头，按压缩类型，编码类型

#### **http报文首部有哪些，分别代表什么含义**+

包括请求行（url，get/post，版本1.1/2.0）和请求头，请求体

**请求相关**：请求文件路径，token，cookie，响应码

connection（长连接）：keepalive任意一端没有明确提出断开连接，则保持 TCP 连接状态

keepalive_timeout：长连接超时时间，防止不再发送请求的连接浪费资源

**内容相关**：content length（解决粘包）Content-Type（返回的数据格式）: text/html;   Charset=utf-8  Content-Encoding（使用了什么压缩格式）: gzip

**缓存相关**：（强制缓存、协商缓存）协商缓存需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候（过期）才能发起带有协商缓存字段的请求

Cache-Control， 是一个相对时间；第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小  Expires，是一个绝对时间；

浏览器判断没过期，强制走缓存

协商缓存：一般浏览器判断过期了，去问服务器这个还能不能用，可以是基于时间的，也可以是基于tag的

第一次回复除了消息还回tag，浏览器把tag记住；缓存过期了把tag带上

基于tag的更好：解决即使没有修改时间也可能变化，解决1s内修改多次

If-Modified-Since(浏览器)，Last-Modified（服务器），Etag，If-None-Match（基于唯一标识）

![image-20240301154158525](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20240301154158525.png)

![image-20240301154220626](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20240301154220626.png)

![image-20240301154426222](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20240301154426222.png)

#### http常见的状态码

2（正常返回，返回无数据，返回部分），3（临时重定向，永久重定向，使用缓存资源），4（请求了非法的资源，不存在的资源），5（功能未实现，网关的后端服务器发生错误，服务器繁忙）

#### http与https

http明文传输，不安全。

需要保证：1.发的内容加密(账号密码等) —— 混合加密 2.返回的资源不被修改 —— 摘要算法

3.访问的是正确的网站 —— CA证书

https解决了：窃听，篡改，冒充，但速度变慢了，消耗服务器资源更多了

http+加密（tls，混合加密）+证书（ca）+完整性检查（摘要算法）=https（保证数据完整安全）

混合加密：非对称加密交换对话密钥，使用对话密钥进行对称加密，**加密内容**，所以抓包了也看不见

​	公钥可以随便发。私钥用于加密，保证消息是我发出的。私钥用于解密，保证只有我能看懂消息

摘要算法，根据内容算哈希值，无法通过哈希值算出内容，哈希值和消息一同传输，**加密对哈希值加密**

端口80/443

对称加密简单，加密速度快，易泄漏要把密钥传给接收方

非对称慢，资源消耗多点，公钥丢了也没事，没法冒充服务器身份

#### tls/ssl的原理，握手挥手流程

浏览器请求服务器公钥，双方协商产生会话密钥，使用会话密钥加密通信。本质上就是使用对称密钥加密信息，为了密钥安全使用非对称加密密钥

1. **客户端Hello**：客户端初始化一个随机数，并给出自己支持的加密算法。

2. **服务器Hello**：服务器选择一个加密算法和数字证书和一个随机数发送给客户端（数字证书中有公钥）。

3. **客户端回应**：客户端验证服务器的数字证书的合法性，取出公钥，生成第三个随机数，用公钥加密发给服务器，同时通知之后的信息使用会话密钥加密。会话密钥由三个随机数和约定的加密算法生成

4. **服务器最后回应**：用私钥解密第三个随机数，生成会话密钥，通知客户端之后使用会话密钥加密。

   注意：保密要求服务器私钥一定不能泄漏
   
   注：前两次随机数没加密；第三次握手，发送的是加密的随机数，会话密钥是三个随机数加算法生成

挥手过程包括：

1. **客户端发送关闭通知**：客户端向服务器发送一个关闭通知。
2. **服务器响应关闭通知**：服务器收到关闭通知后发送一个确认通知。
3. **连接关闭**：客户端和服务器都确认连接关闭，关闭TLS/SSL连接。

**补：ca证书流程** 1.服务器将公钥，用途，过期时间等信息发给ca，ca将内容计算成哈希值，使用**私钥对哈希值加密**，接收者也计算内容哈希2，然后使用ca公钥解密哈希1，对比哈希1和2是否相等

**32）如何防止前端发过来的数据被篡改？**

https

**33）md5加解密，可逆嘛？**

MD5是不可逆的哈希函数，它将输入的数据生成一个128位的哈希值，不同的输入会得到不同的哈希值，但无法从哈希值还原出原始数据。因此，MD5是不可逆的，无法进行解密。（产生初始isn？）

**34）对称加密，安全吗**

对称加密使用同一个密钥进行加密和解密。对称加密的安全性取决于密钥的安全性，如果密钥泄露，那么加密的数据就会暴露。因此，在传输密钥的过程中，需要使用其他加密算法，或者使用非对称加密算法来保护密钥的安全。

#### http1.1、http2.0、http3.0

1.1（长连接）

2.0（头部压缩，二进制分帧，并发传输，服务器推送）

头部压缩：发了多个请求，请求头一样或相似，协议会消除重复的部分

二进制：200（http1.1）->'2''0''0'(http2) ->10001000(直接二百的二进制)

分帧：把http1.1的内容分为头信息帧和数据帧，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容

多路复用：多个 Stream 复用在一条 TCP 连接，不同请求用StreamId区分，接收方根据id组装，不同Stream可以乱序发送，即并发传输stream响应

服务器推送：客户端和服务器双方都可以建立 Stream，客户端请求html，服务器可以主动推送css

缺点：

1.1 发送方可以不等待响应，直接发12345，但接受方应用层必须先处理1，返回，再处理2345

2.0 可以并发发送12345(只要求同一stream内部有序)，然后接收方收到全传给应用层，应用层并发处理

但http2仍存在队头阻塞，是在TCP层，TCP面向字节流，**（一旦发生丢包）**前一个包没到，后面的包只能在缓冲区等待。即2丢了，345需要在tcp层等待

虽然分了多个stream，但是在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**

3.0 基于udp的quic

补：http3基于udp的quic实现可靠传输，某个流发生丢包只阻塞这个流，连接建立更快（TCP+tls -> quic内部包含tls）

连接迁移：正常TCP四元组确定一个连接，wifi切到流量，ip变化重现建立连接（3+4握手+慢启动=卡一下），quic通过连接id标记两个端点，同时保留tls密钥等，可以无缝启动新连接

**7）http如何实现长连接**

请求头中加入 `Connection: keep-alive` 实现

**8）http短连接长连接，TCP短连接长连接，二者的关系**

HTTP的短连接和长连接指的是HTTP层面上连接的保持。TCP的短连接和长连接是指TCP层面上连接的保持。HTTP的长连接需要TCP的长连接支持。TCP的短连接和长连接会影响HTTP的短连接和长连接的性能表现。

补：http短连接，完成一次请求响应后释放TCP连接————长连接，一次请求后，后续请求继续使用该连接

keep-alive再http中指长连接，TCP中指保活机制

**9）http断点重传**

每次可以只请求资源的某个部分

传输失败或中断,可以从上次失败的地方继续下载,而不是重新开始。

多线程分块下载。可以开启多个连接从不同位置请求文件,提高下载速度

在 HTTP 请求中,通过 Range 字段指明请求的字节范围;服务器则用 206 Partial Content 状态码返回指定范围的文件部分。

**10）http2.0如何实现多路复用**

http1是请求响应模型，必须完成一个事务（请求响应，才能处理下一个事务）

http2实现了并发传输，通过在一个TCP连接的基础上创建多个stream流，每个stream有独一无二的id用来区分不同消息，将消息分别放到对应的stream里，而不同stream之间是并发传输的，因此不必等待一条消息完全回复完再去回复另一条消息，一个stream阻塞，其他的stream可以正常传输

补：头部压缩，二进制分帧是多路复用的基础

头部压缩：多个请求的头是一样的，会去除重复的部分

二进制分帧：1.1文本格式（200表示为“2”“0”“0”）二进制格式200表示为（11001000），文本格式不好拆分，无法实现并发，二进制可以

同时帧中有stream流id，也可以按优先级处理



**11）http1.1为什么不能实现多路复用**

HTTP1.1是串行传输的，即同一时间只能处理一个请求，必须等待前一个请求的响应返回后才能发送下一个请求

分完帧每个都得带上完整的头，没有头部压缩数据太大，重复率高

#### http和rpc

rpc调用远程方法像调用本地一样，先于http出现，用于cs架构，本地软件调用远程服务器的方法

后来产生浏览器，可能会访问多个服务器，要有一套统一的协议，产生了http

服务发现：http靠dns，rpc靠注册中心

rpc性能比http1.1好，因为http序列化用json，rpc用解析效率更高，空间占用更好的序列化协议，如Protobuf 

rpc需要调用方和接收方都得引入相关支持，消息头之类的(encode)，需要双方都支持序列化，二进制可读性差，适合方法调用

http更重一点，json可读性好，规则统一，适合浏览器通信



**13）websocket与http的区别是什么？**

WebSocket是一种全双工通信协议（http1.1半双工），允许服务器向客户端推送消息，实现实时双向通信。

流程：先进行一次http通信，请求升级协议，之后按websocket格式发 **应用场景**：需要浏览器服务器频繁交互的（网页游戏，聊天室）

补：为了实现服务器主动推送： 不断轮询，定时轮询（伪）

**14）cookie和session二者的流程、实现原理和区别**

- **Cookie**：存储在客户端的小段文本信息，由服务器发送到客户端，并随后每次请求发送到服务器。Cookie有过期时间。储存偏好设置等不太敏感的数据
- **Session**：服务器端存储的用户状态信息，通常存储在服务器的内存中，通过id关联不同用户。Session由服务器设置过期时间。储存更敏感的数据（购物车，登录状态等）流程：服务器创建一个session对象和一个id绑定对象，将id发给浏览器，之后请求带上id，服务器根据id找到对象识别身份
- cookie是服务器解析cookie中的内容，session是根据id查找服务器的内容，储存数据更多，安全性更高

**15）如何实现cookie**

服务器接收第一次请求的时候，生成一个cookie，内容可能包括名称、值，过期时间，域名等，而后服务器在响应头加入set——cookie字段，将cookie发送给客户端，之后客户端的请求会在请求头加上这个cookie，以便服务器识别身份

#### get和post

语义：查/改

参数传递方式：拼接url/请求体

数据长度限制，安全性

是否能缓存，是否幂等

**网络代理正向和反向区别？**

正向代理：客户端向代理服务器发送请求，代理服务器代表客户端向服务器发送请求

用于隐藏用户访问记录，解决跨域问题，绕过网络限制，访问被封锁的网站，目标服务器对代理服务器可见，对客户端不可见，可以缓存请求的资源，提高访问速度

反向代理：客户端向反向代理服务器发送请求，反向代理服务器根据请求的内容和规则，将请求转发给后端的目标服务器

用于负载均衡、高可用性、安全过滤、SSL加密等。

### tcp

a**17）TCP三次握手和四次挥手标志位、状态位、如何用linux命令查看**

标志位状态位？（syn，ack(除最开始一直置1)，rst，fin）（syn-sent,syn-received）

（fin_wait1,fin_wait2,time_wait,closed_wait,last_ack）

netstat-napt

**TCP头：**

源端口目标端口，序号，确认号，（头部长度，状态位，窗口大小），（校验和，）（可选区：MSS大小、窗口扩大、SACK，对齐数据），因此**TCP头是可变长**的（固定长度20字节，可变长度40字节）而udp头长是固定大小的8字节

**补**：为什么需要 TCP 协议？ TCP 工作在哪一层？希望各层简单专注，IP层不可靠

**补**：什么是TCP？（面向连接可靠字节流的协议）什么又是TCP连接？（保证可靠传输，流量控制等状态信息的组合，包括socket，序列号窗口大小）

**udp头**：

源端口 目标端口 包长度 校验和

TCP有头部长度，没包长度，udp没头部长度，有包长度

udp包长：包长 - 包头（固定大小） / ip包长 - ip包头 - 定长udp包头

tcp包长 = ip包长 - ip包头 - tcp包头(首部字段)

**TCP和udp的区别、应用场景**

面向连接，可靠（各种特性），字节流。

头部大小，传输速度，多了（连接，确认，重传）更慢  

应用场景（http，ftp）（语音视频，dns）

如何查看tcp还是udp：看ip包头，或netStat

a**如何理解TCP的流的概念？TCP粘包？**

TCP是以字节流的形式传输出去的，没有边界，接收到应用层的消息序列化成字节流，放到内核协议栈等待发送，一般一个mtu一个包，而非一条消息一个包，所以会发生沾包，需要在应用层定义消息结构，说明消息的长度，以便于接收方解析，或者是以特殊字符作为边界

如rpc项目，发送的是元数据，元数据有ip和端口号和rpcMess，rpcMess包括header和Mess，header中就有消息长度，是序列化后，计算，填充的

而UDP面向报文传输，每个数据包都是独立的

补：mtu是ip包大小，mss是去掉ip头和TCP头，一个包能容纳的最大TCP数据的大小

a**20）TCP三次握手，为什么不是两次握手和四次握手**

接收端收到，也随机初始化一个序号，放到序列号，将收到的客户端序列号加一放入确认应答号，syn，ack置1，自己进入syn-received状态。**1.保证双方都具有接收发送能力**

**2.防止历史连接初始化连接**，因为接收方没有中间状态（syn-received）给发送方阻止历史连接，收到syn就建立了一个连接（这时候服务器可能向这个废连接发送消息，白发送）

发了个syn90，阻塞了，重发了个syn100；90到了，返回91；接收想要101，因此不会建立这个连接，会回一个rst。如果接收方没有中间态，就会给91建连

**3.正确同步双方初始序列号**，两个以来一回，中间的两次可以合并成一次

**4.防止资源浪费**，没有第三次握手，服务器不知道对方是否接到回复的ack，收到一个syn就创建一个连接

补：syn攻击，攻击方伪造不同ip，发送syn报文，占满半连接队列。解决方法：调大缓冲区，调大半连接队列，使用cookie绕过半连接，减少syn-ack重传次数，尽快断开半连接

#### TCP四次挥手，三次行不行

发起（fin-wait1,fin-wait2,**time_wait**）被动方(**closed-wait**，last_ack)

两个方向，每个都需要一个fin和一个ack

第一次：客户端不在发送但是可以接收 	第二次：服务器收到，但可能还需要处理发送数据

第三次：服务器处理完成，同意现在关闭连接 	第四次：客户端收到

总结：因为服务器还需要进行最后的数据处理发送，所以服务端的ack和fin一般要分开发送，所以是四次

补：fin包会在收到的时候给后面插个eof，然后用户read就知道后面没数据了，等自己要发的发完了，就发第二个fin

补：time_wait不会持续很长时间，有一个默认值，一般60s，超时没收到第三次握手的fin自动关闭连接(调close)

​		服务器重传，客户端收到新的fin后，会重置2msl定时器

补：进程退出，不管是正常还是异常退出，会主动发fin报文

补：关闭连接有两种方法，close()粗暴的，调用之后socket不能读不能写；shutdown()优雅的，调用之后不能写，可以读

补：四次可以变三次，甚至可能三次过多，tcp默认开启**延迟确认**机制，需要回复ack的时候，如果有响应数据需要发送，ack和响应数据一起发送；没响应数据会等一会，等到有响应一起发送；等待过程收到第二个数据，立即回复ack

a**28）time_wait是主动断连方的，存在的原因是什么，哪些应用场景要调小time_wait的时间长度**

作用：1.防止历史连接中的数据，被后面相同四元组的连接错误的接收，2msl足以让两个方向的数据包都被丢弃

2.保证「被动关闭连接」的一方，能被正确的关闭，确保ack能被被动关闭方接收进而正常关闭

**补：**为什么是2msl，一来一回的时间，至少允许报文丢失一次，即客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间

#### 大量time_wait

TIME_WAIT状态是主动断连方的状态。

原因：短连接频繁建立和关闭：比如频繁地连接数据库、调用接口等，并且连接使用完毕后立即关闭

1.没开启长连接2.长连接超时（网络不好导致服务器一直没收到请求）3.（单个长连接有最大请求数量限制，qps太高就会出现频繁的断开连接，需要调大**keepalive_requests**）

在高并发、短连接频繁建立的应用场景下，可能会调小TIME_WAIT的时间长度，以减少资源占用。 

解决方案：长连接；使用连接池；调小时间长度

#### 大量close_wait

服务端收到第一次fin之后，把要发的发完，之后调close()，发fin包，才能进close_wait()

我们先来分析一个普通的 TCP 服务端的流程：

1. 创建服务端 socket，bind 绑定端口、listen 监听端口
2. 将服务端 socket 注册到 epoll
3. epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket
4. 将已连接的 socket 注册到 epoll
5. epoll_wait 等待事件发生
6. 对方连接关闭时，我方调用 close

一般都是编码出问题导致：没accept或accept后没把已连接socket注册到epoll，服务端就没法感知到相关事件，也就没法调用close

#### RST

表示这个连接有问题，需要立即终止；是异常情况下的终止连接，强制的，单方面的，没有四次挥手

用于快速处理异常，避免浪费时间和资源

如遇到非法源ip；客户端调用close粗暴关闭，然后又收到了服务器发的数据；socket长期没被accept

主动中断连接的一方，也就是发送rst的一方，释放资源(socket)，通知对方中断(发送rst标志的报文)

不优雅的关闭有什么问题：因为是强制的，没协商，可能有数据丢失？rst之前发的数据，但是在rst之后到；然后缓冲区数据也会被直接清空，可能还有需要发的

补：除收到消息外，收到rst，fin，都会使tcp句柄产生可读事件

#### **TCP如何保证可靠传输**

序列号确认号保证不乱序不重复不丢包，丢失超时重传。校验和保证数据完整。

滑动窗口配合流量控制（接收方告知自己接收能力，发送方控制发送速率）4.拥塞控制（动态调整发送方的发送速率，避免网络拥塞）

补：校验和：TCP 对头部和数据进行校验和计算,用于检查数据在传输过程中的完整性。

**24）如何让udp实现可靠传输**



#### **TCP的重传机制**

有超时重传和快速重传

超时重传就是发包之前计时，超过指定时间没ack就重传

但是这个规定时间怎么搞，太短可能因为拥塞回ack慢了，你重传反而加大压力；太长如果真丢包了，老半天没重发，性能差

这个值是动态变化的，所以要尽可能配合网络状况，精确测量这个时间，一般略大于2rtt；具体靠采样加权平均，有个计算公式

超时重传之后，下一次的超时时间间隔设置为上一个的二倍

#### 流量控制

滑动窗口（Sliding Window）机制实现。接收方通知发送方自己的接收窗口大小，发送方根据这个窗口大小控制发送的数据量，确保不会发送过多的数据导致接收方无法处理

a**滑动窗口是怎么实现的？**

窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值

发送方会有一个缓冲区，再收到确认应答之前，在缓冲区保存发送的数据，如果按期收到，从缓冲区删除；还会配合**累计确认**，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据全收到了，允许确认应答报文丢失

TCP头中有一个字段，用于接收方告诉发送方自己还有多少缓冲区可以接收数据，窗口是大小动态变化的  

发送方的滑动窗口分四部分，1.已发送并ack--2.已发送未收到ack--3.未发送但可以发送--4.未发送且超出接收方处理能力

接收方的滑动窗口分三部分，1.已接收并ack--2.还能接收的--3.超出接收能力的

#### 拥塞控制

TCP的拥塞控制通过拥塞窗口机制实现。发送方根据网络拥塞的程度动态调整拥塞窗口的大小，以控制发送速度。TCP的拥塞控制算法包括**慢启动、拥塞避免、快速重传和快速恢复**等。一旦发生了超时重传，认为发生网络拥堵，调整窗口大小

慢启动：一开始拥塞窗口较小（慢启动），收到一个ack拥塞窗口加一，每一轮次指数增长，直到达到阈值

拥塞避免：达到慢启动门限，上一轮次所有发出的包都被接收，拥塞窗口加一，每一轮次线性增长

快重传：丢了一个中间包的时候，接收方回复三次前一个包的 ACK，发送方连续收到三个重复的ack，直接重传，不用等待超时

快恢复：发生快重传，还能收到 3 个重复 ACK 说明网络也不那么糟糕，情况不严重，大部分没丢，只丢了一小部分，拥塞窗口大小变为原来的一半，慢启动门限等于，拥塞窗口大小，然后收到重复的ack就把窗口大小加1，以实现将丢失的包尽快发给目标，收到新的ack，拥塞窗口大小变回快恢复发生的时候，即慢启动门限的大小

a**29）TCP中，为啥有了流量控制，还需要拥塞控制**

流量控制根据接收方处理能力调整发送方的发送速度，防止来接收方不及处理占满缓存区丢包（避免「发送方」的数据填满「接收方」的缓存）

拥塞控制防止网络环境问题丢包（避免「发送方」的数据填满整个网络）（慢开始，拥塞避免，快重传与快恢复）

发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个

即使单个连接进行了流量控制，但在多个连接同时进行数据传输的情况下，仍然可能因为网络拥塞导致数据丢失，因此需要拥塞控制来适应整体网络状况。



**35）网络编程中，如何去掉time wait时间**

可以通过设置操作系统的相关参数来调整TIME_WAIT时间。例如，在Linux

系统中，可以使用以下命令来修改TIME_WAIT的超时时间

### ip

#### mtu

ip层的包大小，mtu的值是协商出来的，一般1500(不建议改)，越大效率越好(单包数据多，传输次数少)，但更容易导致网络阻塞；更容易导致消息错误；需要更长的处理时间。

可以ping来测试一个合适的大小，直到ping不到结果显示超时

ip层发现大于mtu会分片，涉及到包的复制，开销大，尽量别超

可以计算出一个mss，mtu-ip包头-tcp包头，让tcp流式数据打包的大小别超过这个mss

**30）接收端如何判断ip数据报是否完整（从网络编程角度）**

补：ip头：版本，首部长度，总长度，标识？标志+片偏移，ttl，上层协议，首部校验和，源ip，目标ip

长度，序号，偏移，校验和

**IP 报文的TTL是什么意思？**

最大跳数，防止路由循环

TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。Maximum Segment Lifetime，报文最大生存时间

#### ping

ping的时候，发生了什么用了哪些协议，源ip和目的ip在过程中是如何变化的

**ICMP**（Internet Control Message Protocol）传输控制协议，用于判断ip包是否能正确送达，发送过程中ip包被废弃的原因，如主机a找路由器，路由器找主机b，路由器arp求mac的时候，主机b关机了，路由器就会给主机a回个icmp，内容类型写目标不可达

ping就是 发送端发个icmp，接收方回个icmp。里面会记录发送给时间和接收时间

在Ping过程中，源IP地址是发送端主机的IP地址，而目的IP地址是要Ping的目标主机的IP地址。这两个IP地址在整个Ping过程中保持不变。

补：icmp分两类：查询报文类型（request，reply）和差错报文类型（目标不可达，超时，重定向）

可以主动去犯错，以此来获得一些网络相关的信息

#### 什么是子网，如何求子网掩码

电脑有多个网卡，目标地址与自身子网掩码与运算，和destination比较，判断使用那个网口

自身ip与子网掩码运算，得到自身所属哪个子网

子网（Subnet）是将一个大的IP网络划分成若干个小的网络，以提高网络的性能和安全性。子网掩码（Subnet Mask）是一个32位的二进制数，用于区分IP地址中网络部分和主机部分。

确定需要多少主机，判断需要几位主机号，确定要划分几个子网，确定借用几位做子网号

如：需要254个主机，划分四个子网，则应该255.255.255.192

### sock

#### socket

socket是个接口，是一组函数和数据结构的集合，在应用程序中使用这些接口可以方便地实现网络数据的发送和接收。

 `socket`、`bind`、`listen`、`connect`、`accept` 这类网络编程函数，属于用户空间（应用区）可调用的系统调用接口，应用程序通过这些接口与操作系统内核进行交互以实现网络通信功能。

函数内部会调用其他内核区函数，如：内核分配socket空间，创建全连接队列，调用三次握手，内核区创建连接socket。这样起到了屏蔽底层操作，内核统一管理资源等作用，使得开发者无需深入了解内核的复杂实现细节，就能实现网络通信功能。

杂：

socket是有状态的，像CLOSED,SYN-SENT,SYN-RECEIVED这些三次握手的状态也就是socket的状态

应用层创建socket，这个过程会发生系统调用，因为涉及到内存分配，返回一个文件描述符

send是一个函数，应用调这个函数，把要发的东西告诉他，类似把要做的事告诉内核，然后内核把这个事干完。

中间会发生一次拷贝，把应用层数据拷贝到内核中socket申请的空间

**socket的返回值是什么**

返回一个文件描述符（File Descriptor），后续通过这个文件描述符操作socket

文件描述符表是内核管理的一个表格，每一个条目包括一个文件描述和指向所需文件的指针

文件描述符储存在用户空间，进程打开或创建一个文件，内核分配一个文件描述符，并添加对应条目，完成映射，之后以文件描述符为参数，内核根据文件描述符找到文件描述符表，找到对应文件，完成io	

补：epoll基于事件驱动，同时监控多个文件描述符，某个描述符就绪，epoll得到通知（epoll就是监控文件的，看文件是不是发生了io）

补：bind，listen，监听socket注册epoll，三次握手完成进入已连接队列，内核通过回调通知epoll，产生accept事件通知应用，**应用程序**调用accpet，生成一个已连接socket（有缓冲区等资源），已连接socket也注册到epoll，记录连接上的事件，然后返回文件描述符

**socket通信服务端的流程**（如果要实现一个TCP服务器要哪些（套接字）接口）

socket bind listen accept read write connect

##### 半连接和全连接队列

半连接队列是个链表或哈希表，里面每个具体条目存了客户端的 IP 地址、端口号，以及服务器为此次连接分配的初始序列号，超时信息等，没有socket的文件描述符。如，哈希表以ip+端口作为key，todo：因为这时候还没创建连接socket，所以占用空间小

全连接队列每个条目包含了客户端和服务器的完整连接信息，如客户端和服务器的 IP 地址、端口号，以及每个连接都会关联一个已连接的 `socket` 资源，所以内存比半连接更大。（但貌似并非是直接可用的套接字描述符。在 `accept` 函数内部，会基于这个内核数据结构创建一个新的套接字描述符。（也有说已经关联了一个可用的 `socket` 描述符，可直接用于数据通信））

为什么要有半连接队列：如果收到一个syn就创建一个消耗很大的sock，很容易内存耗尽。所以内核在三次握手成功之前，只分配一个占用内存极小的request_sock，可以防止syn攻击

同时，因为全连接队列里面保存的是占用内存很大的普通sock，所以Kernel给其加了一个最大长度的限制。

##### 创建监听socket

```
// sockfd代表一个已经分配好资源的套接字对象
int sockfd = socket(AF_INET, SOCK_STREAM, 0);

address.sin_family = AF_INET;
address.sin_addr.s_addr = INADDR_ANY;
address.sin_port = htons(PORT);

// 绑定套接字到指定地址和端口
if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
    perror("bind failed");
    exit(EXIT_FAILURE);
}
```

- `AF_INET`：表示使用 IPv4 地址族。
- `SOCK_STREAM`：表示使用面向连接的 TCP 协议。
- `0`：通常表示使用默认的协议。

+ int：返回文件描述符

- **创建套接字**：首先使用 `socket` 函数创建一个套接字，这只是创建了一个用于网络通信的端点，但此时还没有与具体的地址和端口关联。
- **初始化 `sockaddr` 结构体**：创建一个 `sockaddr` 类型（实际常用 `sockaddr_in` 等具体结构体）的变量，并将服务器要监听的 IP 地址和端口号填充到该结构体中。
- **绑定地址**：使用 `bind` 函数将套接字与初始化好的 `sockaddr` 结构体绑定，这样套接字就与特定的地址和端口关联起来，可以开始监听该地址和端口上的连接请求。

##### listen

```
全连接队列是在调用listen中创建并初始化
#define BACKLOG 5    全连接队列长度
if (listen(server_fd, BACKLOG) < 0) {
    perror("listen failed");
    exit(EXIT_FAILURE);
}
```

##### connect

调用connect时，要求已经有创建好的socket，以及已填充好的`serv_addr` 结构体。

三次握手发生在connect内部

当调用 `connect` 函数时，会触发 TCP 的三次握手过程。`connect` 函数会将初始化好的 `serv_addr` 结构体中的服务器地址信息传递给内核，内核协议栈向目标服务器发送 SYN 包

connect成功后，用户就可以通过且只需该socket像服务端发信息

数据通常会按照 “用户空间 -> 内核中套接字缓冲区 -> TCP 内核协议栈 -> 网卡” 这样的路径进行传输

补：connect发送了什么报文？syn(三次握手第一次)

补：udp能用connect吗？能，虽然是无连接的。创建socket指明tcp还是udp，然后connect根据类型判断具体怎么做，udp的话也要绑定服务器ip端口，方便后续收发，但没三次握手

```
sock_fd = socket(AF_INET, SOCK_STREAM, 0);
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(PORT);

if (connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
    perror("connect failed");
    exit(EXIT_FAILURE);
}

if (send(sock_fd, message, strlen(message), 0) == -1) {
    perror("send failed");
    exit(EXIT_FAILURE);
}
close(sock_fd);
```

##### accept函数

accept 函数会从队列头部取出一个已经完成三次握手的连接条目，创建一个新的套接字用于与该客户端进行数据通信，并将该连接从全连接队列中移除

```
conn_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);
	accept内部：
		看全连接列是否为空，若为空，且阻塞式socket，挂起当前线程
		否则从队列中取出一个连接
		创建一个新的套接字描述符。并非简单调用socket()，现在是在内核区，而这是一个用户区函数
		将客户端的地址信息复制到 addr 所指向的结构体中，并更新 addrlen 的值
		返回新的套接字描述符
```

- 参数解释：
  - `listenfd`：监听套接字的文件描述符，这个套接字是通过 `socket` 函数创建，并通过 `bind` 函数绑定到指定的地址和端口，再通过 `listen` 函数开始监听客户端连接请求的。
  - `client_addr`：指向一个 `sockaddr` 结构体的指针，创建初始化后，传到函数内部，用于存储客户端的地址信息，包括 IP 地址和端口号。
  - `client_addr_len`：指向一个 `socklen_t` 类型的变量的指针，用于指定 `addr` 结构体的长度，在函数返回时，该变量会被更新为实际存储的客户端地址信息的长度。

- 返回值：
  - 如果函数调用成功，会返回一个新的套接字文件描述符，这个新的套接字用于和客户端进行数据传输。原来的监听套接字 `sockfd` 继续保持监听状态，等待其他客户端的连接请求。
  - 如果调用失败，返回 -1，并设置相应的错误码。

##### 如果没有accept

三次握手只是在网络**传输层**确立了连接，应用层没法直接收发，需要有一个内核和应用之间的接口（socket），通过该socket进行read

如果没accept，三次握手正常进行，全连接队列正常存入相关信息，已连接socket正常创建，但应用层无法获得socket相关句柄，收到的数据停留在socket缓冲区，无法被应用读取

同时，因为没有使用accept从全连接队列取出，队列堆满，后续连接完成三次握手后无法加入队列，回复rst给客户端。

同时，内核可能会将超过一定时间未被accept的连接视为超时并主动关闭它们，同时发送 RST 包给客户端



### io多路复用

把多个文件描述符集合起来，交给内核统一监管。

不同的 I/O 多路复用技术（如 `select`、`poll`、`epoll`）有不同的方式来管理这个文件描述符集合。

select和poll都是线性储存这些文件描述符。事件发生；遍历找到可读写的，复杂度o(n)；标记；拷贝把所有都拷贝到用户区；用户遍历，找到有标记的。

区别在于poll能存的文件描述符更多些。(select用map，最多1024，poll用链表)

I/O多路复用是一种通过单一的事件循环机制来管理多个I/O操作的技术。它使得程序能够同时监控多个文件描述符（sockets、files等），在任一文件描述符就绪时进行相应的I/O操作，而无需为每个I/O操作创建单独的线程或进程。

#### epoll具体流程

新连接发生时，监听socket中发生事件，使epoll_wait苏醒，accept拿到新的socket，并将其注册到epoll中，以便后续监控这个新连接上的事件

用户创建一个epoll，返回文件描述符，把已连接socket注册到epoll(构造events对象，调epoll_ctl)，把sock拷到内核，加入红黑树

事实上是epoll_wait被调用的时候，遍历红黑树，找到有事件的，调用回调函数，把符合规则的事件加入链表。

然后把链表拷过去(非阻塞，如果没数据，wait直接返回)

用户区：遍历events，逐个调用read；

```
int epoll_fd = epoll_create1(0);

// ev和events，events是struct ev的数组，用来接收内核返回的就绪事件信息
// 也就是把就绪事件链表拷到数组，epoll_wait返回拷了多少个，数组也只填充前n个
struct epoll_event ev, events[MAX_EVENTS];

// 把新socket(已连接)加入epoll
fd = cnn_sock
// 填充ev结构体，一个事件中包括sock文件描述符和事件类型
ev.events = EPOLLIN; // epollin可读事件;epollout可写
// 水平和边缘设置在ev结构体的角度 ev.events = EPOLLIN | EPOLLET; 
ev.data.fd = fd;

// ev绑定到epoll 
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &ev)

while(1){
    // n是事件个数，返回的event的个数，sock在event里，所以也是有新io的sock个数
    // 非阻塞只没数据(空链)时epoll-wait立刻返回，返回0
    // 只需要epoll的文件描述符和接收返回的事件数组
    int n = epoll_wait(epoll_fd, events, MAX_EVENTS, -1); 
    // 处理事件
    for (int i = 0; i < nfds; i++) {
        // 处理相应事件，对有数据的sock，调read
        // read 函数每次只读取 BUFFER_SIZE 大小的数据
        ssize_t bytes_read = read(events[i].data.fd, buffer, BUFFER_SIZE);   
	}
}
```

#### 水平触发和边缘触发

有个sock有数据没读完，epoll是否会触发事件，把该sock加入就绪链表

水平：只要有没读完的就触发，epoll默认是水平，select/poll只有水平

边缘：只有状态发生变化才触发(来新数据)，所以需要尽可能读，

```
 for (int i = 0; i < nfds; i++) {
	 while ((bytes_read = read(events[i].data.fd, buffer, BUFFER_SIZE)) > 0) {}
}
```

所以read要非阻塞。

一般来说，边缘触发的效率比水平触发的**效率要高**，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。

补：因为read不一定一次性读完

补：epoll-wait调用时，拷贝链表到用户，这个过程会加锁，过程中有新事件发生，无法添加至链表，而是阻塞等待

补：

阻塞和非阻塞指的是用户调用read，内核没有可读数据，是阻塞等待，还是直接返回。

阻塞io：调用read()，内核没有准备好的数据，执行线程阻塞等待；非阻塞io直接返回

内核有数据，还需要cpu拷贝到用户，无论阻塞还是非阻塞，这个过程都是同步的

异步io：线程发起aio_read()，直接返回；一个其他内核线程，等到内核准备好数据，拷贝到用户区，再通知原线程处理数据

### **补：**

网络性能指标：带宽、延时、吞吐率、pps

查看网络配置：ip、ifconfig
 内容包括：IP 地址、子网掩码、MAC 地址、网关地址、网口的状态以及网络包收发的统计信息

查看协议栈里的信息：socket信息，网口，路由表：netstat、ss

收到的数据包被修改了怎么办：本身有校验和（不提供加密和身份验证），被修改了直接丢，数字签名（私钥加密，公钥解密确保消息来源），tls加密，摘要算法进行完整性检查，

**长链接和短链接的互相转换**

？

**如何衡量网络性能**

网络性能：带宽（链路的最大传输速率），时延，吞吐率（单位时间成功传输的数据量）PPS（单位时间传输包的数量）

吞吐量：io多少字节

吞吐率：完成多少任务

### todo

#### http连接池是咋回事

客户端这面的，复用三次握手
