**1）五层模型、七层模型各层模型的名字、原理；常用的部件和协议**

应用，表示，会话，传输，网络，数据链路，物理

应用，**传输，网络**，网络接口-------------------------------------------------------（dhcp：动态获取ip地址，dhcp服务器统一分配和管理IP地址）

**应用**：确定通信的性质，给应用程序或者说用户提供一个统一的接口**（dns，http，HTTPS，dhcp，ftp，smtp）**

**表示**：解决用户信息的**语法表示**问题，确保一个系统的应用层发送的数据能被另一个系统的应用层识别，**如数据转换，压缩加密，解密**。

**会话**：**建立、管理和终止表示层实体之间的通信会话**，如服务器验证**用户登录**

（给消息进行编号，并处理确认应答，全双工保持两个方向的数据独立性）（rpc，socket）

内核：

**传输**（mss段）：不同主机上**进程**间的数据**通信**，tcp/udp

**网络**（mtu包）：通过**IP寻址**来建立两台**主机**之间的**连接**，远程定位，路由选择，实现非同一子网间的数据传输

网络层（IP协议）本身没有传输包的功能，包的实际传输是委托给数据链路层（以太网中的交换机）来实现的**（ip，icmp）**

**数据链路**（帧）：用**MAC**地址访问媒介，增加检验去除mac头，判断是否是发给自己这个物理地址的（arp）

**物理**：物理设备（网卡网线），光电信号和数字信号间的转化，帧头帧尾，判断是否因噪声等问题导致信号失真

补：链路层的传输能力，会动态变化，受网络环境硬件能力影响

mtu的值是协商出来的，一般1500，越大效率越好（有效内容多），但容易阻塞，所以可以ping来测试一个合适的大小，直到ping不到结果显示超时

**补：三张表：路由表，arp缓存表，mac地址表**

以太网是实现局域网的有线网络技术。最常见的局域网即是以太网,通过交换机/集线器连接

同一以太网通过交换机直接发。判断是否同一子网，不是则发给默认网关（路由器的ip地址），arp表查路由器的

mac，送到路由器，路由器查路由表，判断要到达目标ip要从哪一端口出去，找到了目标子网后，arp查目标机器

的mac地址，送到交换机，查mac地址表，判断从交换机的哪个端口传输**（不知道数据包下一跳发给谁就发给默**

**认网关）**

**补1**：`ICMP` 用于告知网络包传送过程中**产生的错误以及各种控制信息**

**补2**：收到数据存到网卡ringbuffer，触发中断（先硬后软），中断处理函数拿出一个帧交给协议栈，协议栈先看是否是给自己的（ip，mac）

是的话到传输层，传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。

**补3**：发送网络数据的时候，涉及几次内存拷贝操作？

1.内存区数据拷贝到socket的缓冲区2.tcp发送为了重传会拷贝（传输层到网络层时）3.**ip层发现大于mtu会分片**，涉及到拷贝。其他均通过指针实现 		socket的接收缓冲区是一个指针,指向这个共享ring buffer



**？**内核缓冲区=pagecache=磁盘高速缓存，在内存里，缓存了最近被访问的数据；

**说说一个数据怎么在网络各层分割报文的**

应用层数据包，传输层tcp段，ip包，mac帧

**22）tcp在应用层的应用，udp在应用层的应用呢？ DNS是TCP上层协议吗？**

tcp：HTTP、HTTPS、FTP、SMTP。

udp：DNS（域名系统解析）、DHCP（动态分配ip地址和配置信息）、实时音视频传输

补：为什么dns是udp：为了快速响应，同时udp头部较小，占用网络资源更少，适合dns这种频繁短小的数据交换，可以容忍丢包，实际上dns因为可以使用缓存，不能正常工作的概率低

补：DHCP 交互中，全程都是使用 UDP 广播通信。流程：dhcp发现，提供，请求

**数据链路层有哪些协议？ARP协议的过程？**

ARP 是借助 **ARP 请求与 ARP 响应**两种类型的包确定 MAC 地址的，主机广播发送ARP请求，里面包含目标主机的ip，所有设备同时收到，如果有某台主机发现与自己的ip相同，就把自己的MAC地址放到ARP响应包发送回去

**补：广播和多播**

广播：本地广播直接广播（不转发） 	多播：**将包发送给特定组内的所有主机**（最后一排上来做题）

由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播

### HTTP

**http的特点是什么？**

基于文本，易于阅读和调试，但相比二进制效率低

灵活可扩展，可传输html，json等，可通过扩展头部支持新的功能

无状态，请求之间相互独立，服务器不会保存之前的信息，需要通过cookie，session等储存状态

#### **浏览器输入一个URL的全过程**

（dns解析，三次握手，请求，响应，解析渲染，断连）

解析url（服务器名称，文件路径），生成http请求，dns真实地址查询（浏览器缓存，操作系统**缓存**，host文件，本地dns，权威dns，根dns）

浏览器调用socket库，委托内核协议栈工作（tcp、ip（icmp，arp）），网卡驱动，物理硬件网卡。服务器处理回复，页面渲染

#### **http报文首部有哪些，分别代表什么含义**+

包括请求头（url，get/post，版本1.1/2.0）和消息头，响应头

**请求相关**：请求文件路径，token，cookie，响应码

connection（长连接）：keepalive任意一端没有明确提出断开连接，则保持 TCP 连接状态

keepalive_timeout：长连接超时时间，防止不再发送请求的连接浪费资源

**内容相关**：content length（解决粘包）Content-Type（返回的数据格式）: text/html;   Charset=utf-8  Content-Encoding（使用了什么压缩格式）: gzip

**缓存相关**：（强制缓存、协商缓存）协商缓存需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候（过期）才能发起带有协商缓存字段的请求

Cache-Control， 是一个相对时间；第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小  Expires，是一个绝对时间；

If-Modified-Since，Last-Modified（基于时间），Etag，If-None-Match（基于唯一标识）

![image-20240301154158525](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20240301154158525.png)

![image-20240301154220626](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20240301154220626.png)

![image-20240301154426222](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20240301154426222.png)

#### http常见的状态码

2（正常返回，返回无数据，返回部分），3（临时重定向，永久重定向，使用缓存资源），4（请求了非法的资源，不存在的资源），5（功能未实现，网关的后端服务器发生错误，服务器繁忙）

#### http与https

http明文传输，不安全。

需要保证：1.发的内容加密(账号密码等) —— 混合加密 2.返回的资源不被修改 —— 摘要算法

3.访问的是正确的网站 —— CA证书

https解决了：窃听，篡改，冒充，但速度变慢了，消耗服务器资源更多了

http+加密（tls，混合加密）+证书（ca）+完整性检查（摘要算法）=https（保证数据完整安全）

混合加密：非对称加密交换对话密钥，使用对话密钥进行对称加密，加密内容

​	公钥可以随便发。私钥用于加密，保证消息是我发出的。私钥用于解密，保证只有我能看懂消息

摘要算法，根据内容算哈希值，无法通过哈希值算出内容，哈希值和消息一同传输，加密对哈希值加密

端口80/443

#### tls/ssl的原理，握手挥手流程

浏览器请求服务器公钥，双方协商产生会话密钥，使用会话密钥加密通信。本质上就是使用对称密钥加密信息，为了密钥安全使用非对称加密密钥

1. **客户端Hello**：客户端初始化一个随机数，并给出自己支持的加密算法。

2. **服务器Hello**：服务器选择一个加密算法和数字证书和一个随机数发送给客户端（数字证书中有公钥）。

3. **客户端回应**：客户端验证服务器的数字证书的合法性，取出公钥，生成第三个随机数，用公钥加密发给服务器，同时通知之后的信息使用会话密钥加密。会话密钥由三个随机数和约定的加密算法生成

4. **服务器最后回应**：用私钥解密第三个随机数，生成会话密钥，通知客户端之后使用会话密钥加密。

   注意：保密要求服务器私钥一定不能泄漏

挥手过程包括：

1. **客户端发送关闭通知**：客户端向服务器发送一个关闭通知。
2. **服务器响应关闭通知**：服务器收到关闭通知后发送一个确认通知。
3. **连接关闭**：客户端和服务器都确认连接关闭，关闭TLS/SSL连接。

**补：ca证书流程** 1.服务器将公钥，用途，过期时间等信息发给ca，ca将内容计算成哈希值，使用**私钥对哈希值加密**，接收者也计算内容哈希2，然后使用ca公钥解密哈希1，对比哈希1和2是否相等

**32）如何防止前端发过来的数据被篡改？**

https

**33）md5加解密，可逆嘛？**

MD5是不可逆的哈希函数，它将输入的数据生成一个128位的哈希值，不同的输入会得到不同的哈希值，但无法从哈希值还原出原始数据。因此，MD5是不可逆的，无法进行解密。（产生初始isn？）

**34）对称加密，安全吗**

对称加密使用同一个密钥进行加密和解密。对称加密的安全性取决于密钥的安全性，如果密钥泄露，那么加密的数据就会暴露。因此，在传输密钥的过程中，需要使用其他加密算法，或者使用非对称加密算法来保护密钥的安全。

**6）http1.0、http1.1、http2.0、http3.0及其各自的区别**

1.1（长连接）2.0（头部压缩，二进制分帧，多路复用，服务器推送）3.基于udp的quic

补：头部压缩：发了多个请求，请求头一样或相似，协议会消除重复的部分

二进制：200（http1.1）->'2''0''0'(http2) ->10001000(直接二百的二进制)

分帧：把http1.1的内容分为头信息帧和数据帧，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容

多路复用：多个 Stream 复用在一条 TCP 连接，不同请求用StreamId区分，接收方根据id组装，不同Stream可以乱序发送，即并发传输stream响应

服务器推送：客户端和服务器双方都可以建立 Stream，客户端请求html，服务器可以主动推送css

补：http2仍存在队头阻塞，是在tcp层，tcp面向字节流，**（一旦发生丢包）**前一个包没到，后面的包只能在缓冲区等待。

虽然分了多个stream，但是在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**

补：http3基于udp的quic实现可靠传输，某个流发生丢包只阻塞这个流，连接建立更快（tcp+tls -> quic内部包含tls）

连接迁移：正常tcp四元组确定一个连接，wifi切到流量，ip变化重现建立连接（3+4握手+慢启动=卡一下），quic通过连接id标记两个端点，同时保留tls密钥等，可以无缝启动新连接

**7）http如何实现长连接**

请求头中加入 `Connection: keep-alive` 实现

**8）http短连接长连接，tcp短连接长连接，二者的关系**

HTTP的短连接和长连接指的是HTTP层面上连接的保持。TCP的短连接和长连接是指TCP层面上连接的保持。HTTP的长连接需要TCP的长连接支持。TCP的短连接和长连接会影响HTTP的短连接和长连接的性能表现。

补：http短连接，完成一次请求响应后释放tcp连接————长连接，一次请求后，后续请求继续使用该连接

keep-alive再http中指长连接，tcp中指保活机制

**9）http断点重传**

每次可以只请求资源的某个部分

传输失败或中断,可以从上次失败的地方继续下载,而不是重新开始。

多线程分块下载。可以开启多个连接从不同位置请求文件,提高下载速度

在 HTTP 请求中,通过 Range 字段指明请求的字节范围;服务器则用 206 Partial Content 状态码返回指定范围的文件部分。

**10）http2.0如何实现多路复用**

http1是请求响应模型，必须完成一个事务（请求响应，才能处理下一个事务）

http2实现了并发传输，通过在一个tcp连接的基础上创建多个stream流，每个stream有独一无二的id用来区分不同消息，将消息分别放到对应的stream里，而不同stream之间是并发传输的，因此不必等待一条消息完全回复完再去回复另一条消息，一个stream阻塞，其他的stream可以正常传输

补：头部压缩，二进制分帧是多路复用的基础

头部压缩：多个请求的头是一样的，会去除重复的部分

二进制分帧：1.1文本格式（200表示为“2”“0”“0”）二进制格式200表示为（11001000），文本格式不好拆分，无法实现并发，二进制可以

同时帧中有stream流id，也可以按优先级处理



**11）http1.1为什么不能实现多路复用**

HTTP1.1是串行传输的，即同一时间只能处理一个请求，必须等待前一个请求的响应返回后才能发送下一个请求

分完帧每个都得带上完整的头，没有头部压缩数据太大，重复率高

#### http和rpc

rpc调用远程方法像调用本地一样，先于http出现，用于cs架构，本地软件调用远程服务器的方法

后来产生浏览器，可能会访问多个服务器，要有一套统一的协议，产生了http

服务发现：http靠dns，rpc靠注册中心

rpc性能比http1.1好，因为http序列化用json，rpc用解析效率更高，空间占用更好的序列化协议，如Protobuf 

**13）websocket与http的区别是什么？**

WebSocket是一种全双工通信协议（http1.1半双工），允许服务器向客户端推送消息，实现实时双向通信。

流程：先进行一次http通信，请求升级协议，之后按websocket格式发 **应用场景**：需要浏览器服务器频繁交互的（网页游戏，聊天室）

补：为了实现服务器主动推送： 不断轮询，定时轮询（伪）

**14）cookie和session二者的流程、实现原理和区别**

- **Cookie**：存储在客户端的小段文本信息，由服务器发送到客户端，并随后每次请求发送到服务器。Cookie有过期时间。储存偏好设置等不太敏感的数据
- **Session**：服务器端存储的用户状态信息，通常存储在服务器的内存中，通过id关联不同用户。Session由服务器设置过期时间。储存更敏感的数据（购物车，登录状态等）流程：服务器创建一个session对象和一个id绑定对象，将id发给浏览器，之后请求带上id，服务器根据id找到对象识别身份
- cookie是服务器解析cookie中的内容，session是根据id查找服务器的内容，储存数据更多，安全性更高

**15）如何实现cookie**

服务器接收第一次请求的时候，生成一个cookie，内容可能包括名称、值，过期时间，域名等，而后服务器在响应头加入set——cookie字段，将cookie发送给客户端，之后客户端的请求会在请求头加上这个cookie，以便服务器识别身份

**网络代理正向和反向区别？**

正向代理：客户端向代理服务器发送请求，代理服务器代表客户端向服务器发送请求

用于隐藏用户访问记录，解决跨域问题，绕过网络限制，访问被封锁的网站，目标服务器对代理服务器可见，对客户端不可见，可以缓存请求的资源，提高访问速度

反向代理：客户端向反向代理服务器发送请求，反向代理服务器根据请求的内容和规则，将请求转发给后端的目标服务器

用于负载均衡、高可用性、安全过滤、SSL加密等。

a**17）TCP三次握手和四次挥手标志位、状态位、如何用linux命令查看**

标志位状态位？（syn，ack(除最开始一直置1)，rst，fin）（syn-sent,syn-received）

（fin_wait1,fin_wait2,time_wait,closed_wait,last_ack）

netstat-napt

**tcp头：**

源端口目标端口，序号，确认号，（头部长度，状态位，窗口大小），（校验和，）（可选区：MSS大小、窗口扩大、SACK，对齐数据），因此**tcp头是可变长**的（固定长度20字节，可变长度40字节）而udp头长是固定大小的8字节

**补**：为什么需要 TCP 协议？ TCP 工作在哪一层？希望各层简单专注，IP层不可靠

**补**：什么是tcp？（面向连接可靠字节流的协议）什么又是tcp连接？（保证可靠传输，流量控制等状态信息的组合，包括socket，序列号窗口大小）

a**18）tcp和udp的区别、应用场景**

 区别：面向连接，可靠（各种特性），字节流，

头部大小（udp源端口，目标端口，包长度，校验和），tcp有头部长度，没包长度，udp没头部长度，有包长度。

传输速度，多了（连接，确认，重传）更慢  -------  应用场景（http，ftp）（语音视频，dns）

a**如何理解TCP的流的概念？tcp粘包？**

tcp是以字节流的形式传输出去的，没有边界，接收到应用层的消息序列化成字节流，放到内核协议栈等待发送，一般一个mtu一个包，而非一条消息一个包，所以会发生沾包，需要在应用层定义消息结构，说明消息的长度，以便于接收方解析，或者是以特殊字符作为边界

如rpc项目，发送的是元数据，元数据有ip和端口号和rpcMess，rpcMess包括header和Mess，header中就有消息长度，是序列化后，计算，填充的

而UDP面向报文传输，每个数据包都是独立的

补：mtu是ip包大小，mss是去掉ip头和tcp头，一个包能容纳的最大tcp数据的大小

a**20）tcp三次握手，为什么不是两次握手和四次握手**

接收端收到，也随机初始化一个序号，放到序列号，将收到的客户端序列号加一放入确认应答号，syn，ack置1，自己进入syn-received状态。**1.保证双方都具有接收发送能力**

**2.防止历史连接初始化连接**，因为接收方没有中间状态（syn-received）给发送方阻止历史连接，收到syn就建立了一个连接（这时候服务器可能向这个废连接发送消息，白发送）

发了个syn90，阻塞了，重发了个syn100；90到了，返回91；接收想要101，因此不会建立这个连接，会回一个rst。如果接收方没有中间态，就会给91建连

**3.正确同步双方初始序列号**，两个以来一回，中间的两次可以合并成一次

**4.防止资源浪费**，没有第三次握手，服务器不知道对方是否接到回复的ack，收到一个syn就创建一个连接

补：syn攻击，攻击方伪造不同ip，发送syn报文，占满半连接队列。解决方法：调大缓冲区，调大半连接队列，使用cookie绕过半连接，减少syn-ack重传次数，尽快断开半连接

a**21）tcp四次挥手，三次行不行**

发起（fin-wait1,fin-wait2,**time_wait**）被动方(**closed-wait**，last_ack)

两个方向，每个都需要一个fin和一个ack

第一次：客户端不在发送但是可以接收 	第二次：服务器收到，但可能还需要处理发送数据

第三次：服务器处理完成，同意现在关闭连接 	第四次：客户端收到

总结：因为服务器还需要进行最后的数据处理发送，所以服务端的ack和fin一般要分开发送，所以是四次

补：time_wait不会持续很长时间，有一个默认值，超时没收到第三次握手的fin自动关闭连接

服务器重传，客户端收到新的fin后，会重置2msl定时器

a**28）time_wait是主动断连方的还是被动断连方的，存在的原因是什么，哪些应用场景要调小time_wait的时间长度**

TIME_WAIT状态是主动断连方的状态。

作用：1.防止历史连接中的数据，被后面相同四元组的连接错误的接收，2msl足以让两个方向的数据包都被丢弃

2.保证「被动关闭连接」的一方，能被正确的关闭，确保ack能被被动关闭方接收进而正常关闭

在高并发、短连接频繁建立的应用场景下，可能会调小TIME_WAIT的时间长度，以减少资源占用。 

**补：**为什么是2msl，一来一回的时间，至少允许报文丢失一次，即客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间

补：出现大量time_wait,1.没开启长连接2.长连接超时（网络不好导致服务器一直没收到请求）3.（单个长连接有最大请求数量限制，qps太高就会出现频繁的断开连接，需要调大**keepalive_requests**）

**a23）tcp如何保证可靠传输**

1.序列号，确认号（确定已经到达，按序到达）2.超时重传（配合确认号）3.滑动窗口配合流量控制（接收方告知自己接收能力，发送方控制发送速率）4.拥塞控制（动态调整发送方的发送速率，避免网络拥塞）

**24）如何让udp实现可靠传输**



**25）tcp的重传机制**

TCP的重传机制是在发送方发送数据后启动一个定时器，如果在定时器超时时间内未收到接收方的确认应答，发送方会重新发送相同的数据。

a**滑动窗口是怎么实现的？**

窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值，发送方会开辟一个缓冲区，再收到确认应答之前，在缓冲区保存发送的数据，如果按期收到，从缓冲区删除，tcp头中有一个字段，用于接收方告诉发送方自己还有多少缓冲区可以接收数据，窗口是大小动态变化的  还会配合**累计确认**，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据全收到了，允许确认应答报文丢失

发送方的滑动窗口分四部分，1.已发送并ack--2.已发送未收到ack--3.未发送但可以发送--4.未发送且超出接收方处理能力

接收方的滑动窗口分三部分，1.已接收并ack--2.还能接收的--3.超出接收能力的

a**26）tcp的流量控制**

滑动窗口（Sliding Window）机制实现。接收方通知发送方自己的接收窗口大小，发送方根据这个窗口大小控制发送的数据量，确保不会发送过多的数据导致接收方无法处理

a**27）tcp的拥塞控制**

TCP的拥塞控制通过**拥塞窗口**机制实现。发送方根据网络拥塞的程度动态调整拥塞窗口的大小，以控制发送速度。TCP的拥塞控制算法包括慢启动、拥塞避免、快速重传和快速恢复等。一旦发生了超时重传，认为发生网络拥堵，调整窗口大小

慢启动：一开始拥塞窗口较小（慢启动），收到一个ack拥塞窗口加一，每一轮次指数增长，直到达到阈值

拥塞避免：达到慢启动门限，上一轮次所有发出的包都被接收，拥塞窗口加一，每一轮次线性增长

快重传：丢了一个中间包的时候，接收方回复三次前一个包的 ACK，发送方连续收到三个重复的ack，直接重传，不用等待超时

快恢复：发生快重传，还能收到 3 个重复 ACK 说明网络也不那么糟糕，情况不严重，大部分没丢，只丢了一小部分，拥塞窗口大小变为原来的一半，慢启动门限等于，拥塞窗口大小，然后收到重复的ack就把窗口大小加1，以实现将丢失的包尽快发给目标，收到新的ack，拥塞窗口大小变回快恢复发生的时候，即慢启动门限的大小

a**29）tcp中，为啥有了流量控制，还需要拥塞控制**

流量控制是为了控制数据的发送速率，确保接收方能够及时处理数据。拥塞控制则是为了避免网络拥塞，保持整体网络的稳定性。即使单个连接进行了流量控制，但在多个连接同时进行数据传输的情况下，仍然可能因为网络拥塞导致数据丢失，因此需要拥塞控制来适应整体网络状况。

**30）接收端如何判断ip数据报是否完整（从网络编程角度）**

补：ip头：版本，首部长度，总长度，标识？标志+片偏移，ttl，上层协议，首部校验和，源ip，目标ip

长度，序号，偏移，校验和

**IP 报文的TTL是什么意思？**

最大跳数，防止路由循环

**31）ping的时候，发生了什么用了哪些协议，源ip和目的ip在过程中是如何变化的**

**Ping命令使用ICMP**（Internet Control Message Protocol）协议进行工作。当你使用Ping测试一个目标主机时，发送端主机会向目标主机发送ICMP Echo Request消息。目标主机收到消息后，会回应一个ICMP Echo Reply消息。记录发送给时间和接收时间

在Ping过程中，源IP地址是发送端主机的IP地址，而目的IP地址是要Ping的目标主机的IP地址。这两个IP地址在整个Ping过程中保持不变。

补：icmp分两类：查询报文类型（request，reply）和差错报文类型（目标不可达，超时，重定向）

可以主动去犯错，以此来获得一些网络相关的信息

**35）网络编程中，如何去掉time wait时间**

可以通过设置操作系统的相关参数来调整TIME_WAIT时间。例如，在Linux

系统中，可以使用以下命令来修改TIME_WAIT的超时时间

#### 什么是子网，如何求子网掩码

电脑有多个网卡，目标地址与自身子网掩码与运算，和destination比较，判断使用那个网口

自身ip与子网掩码运算，得到自身所属哪个子网

子网（Subnet）是将一个大的IP网络划分成若干个小的网络，以提高网络的性能和安全性。子网掩码（Subnet Mask）是一个32位的二进制数，用于区分IP地址中网络部分和主机部分。

确定需要多少主机，判断需要几位主机号，确定要划分几个子网，确定借用几位做子网号

如：需要254个主机，划分四个子网，则应该255.255.255.192

#### socket

socket是个接口，是一组函数和数据结构的集合，在应用程序中使用这些接口可以方便地实现网络数据的发送和接收。

 `socket`、`bind`、`listen`、`connect`、`accept` 这类网络编程函数，属于用户空间（应用区）可调用的系统调用接口，应用程序通过这些接口与操作系统内核进行交互以实现网络通信功能。

函数内部会调用其他内核区函数，如：内核分配socket空间，创建全连接队列，调用三次握手，内核区创建连接socket。这样起到了屏蔽底层操作，内核统一管理资源等作用，使得开发者无需深入了解内核的复杂实现细节，就能实现网络通信功能。

杂：

socket是有状态的，像CLOSED,SYN-SENT,SYN-RECEIVED这些三次握手的状态也就是socket的状态

应用层创建socket，这个过程会发生系统调用，因为涉及到内存分配，返回一个文件描述符

send是一个函数，应用调这个函数，把要发的东西告诉他，类似把要做的事告诉内核，然后内核把这个事干完。

中间会发生一次拷贝，把应用层数据拷贝到内核中socket申请的空间

**socket的返回值是什么**

返回一个文件描述符（File Descriptor），后续通过这个文件描述符操作socket

文件描述符表是内核管理的一个表格，每一个条目包括一个文件描述和指向所需文件的指针

文件描述符储存在用户空间，进程打开或创建一个文件，内核分配一个文件描述符，并添加对应条目，完成映射，之后以文件描述符为参数，内核根据文件描述符找到文件描述符表，找到对应文件，完成io	

补：epoll基于事件驱动，同时监控多个文件描述符，某个描述符就绪，epoll得到通知（epoll就是监控文件的，看文件是不是发生了io）

补：bind，listen，监听socket注册epoll，三次握手完成进入已连接队列，内核通过回调通知epoll，产生accept事件通知应用，**应用程序**调用accpet，生成一个已连接socket（有缓冲区等资源），已连接socket也注册到epoll，记录连接上的事件，然后返回文件描述符

**socket通信服务端的流程**（如果要实现一个TCP服务器要哪些（套接字）接口）

socket bind listen accept read write connect

##### 半连接和全连接队列

半连接队列是个链表或哈希表，里面每个具体条目存了客户端的 IP 地址、端口号，以及服务器为此次连接分配的初始序列号，超时信息等，没有socket的文件描述符。如，哈希表以ip+端口作为key，todo：因为这时候还没创建连接socket，所以占用空间小

全连接队列每个条目包含了客户端和服务器的完整连接信息，如客户端和服务器的 IP 地址、端口号，以及每个连接都会关联一个已连接的 `socket` 资源，所以内存比半连接更大。（但貌似并非是直接可用的套接字描述符。在 `accept` 函数内部，会基于这个内核数据结构创建一个新的套接字描述符。（也有说已经关联了一个可用的 `socket` 描述符，可直接用于数据通信））

为什么要有半连接队列：如果收到一个syn就创建一个消耗很大的sock，很容易内存耗尽。所以内核在三次握手成功之前，只分配一个占用内存极小的request_sock，可以防止syn攻击

同时，因为全连接队列里面保存的是占用内存很大的普通sock，所以Kernel给其加了一个最大长度的限制。

##### 创建监听socket

```
// sockfd代表一个已经分配好资源的套接字对象
int sockfd = socket(AF_INET, SOCK_STREAM, 0);

address.sin_family = AF_INET;
address.sin_addr.s_addr = INADDR_ANY;
address.sin_port = htons(PORT);

// 绑定套接字到指定地址和端口
if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
    perror("bind failed");
    exit(EXIT_FAILURE);
}
```

- `AF_INET`：表示使用 IPv4 地址族。
- `SOCK_STREAM`：表示使用面向连接的 TCP 协议。
- `0`：通常表示使用默认的协议。

+ int：返回文件描述符

- **创建套接字**：首先使用 `socket` 函数创建一个套接字，这只是创建了一个用于网络通信的端点，但此时还没有与具体的地址和端口关联。
- **初始化 `sockaddr` 结构体**：创建一个 `sockaddr` 类型（实际常用 `sockaddr_in` 等具体结构体）的变量，并将服务器要监听的 IP 地址和端口号填充到该结构体中。
- **绑定地址**：使用 `bind` 函数将套接字与初始化好的 `sockaddr` 结构体绑定，这样套接字就与特定的地址和端口关联起来，可以开始监听该地址和端口上的连接请求。

##### listen

```
全连接队列是在调用listen中创建并初始化
#define BACKLOG 5    全连接队列长度
if (listen(server_fd, BACKLOG) < 0) {
    perror("listen failed");
    exit(EXIT_FAILURE);
}
```

##### connect

调用connect时，要求已经有创建好的socket，以及已填充好的`serv_addr` 结构体。

三次握手发生在connect内部

当调用 `connect` 函数时，会触发 TCP 的三次握手过程。`connect` 函数会将初始化好的 `serv_addr` 结构体中的服务器地址信息传递给内核，内核协议栈向目标服务器发送 SYN 包

connect成功后，用户就可以通过且只需该socket像服务端发信息

数据通常会按照 “用户空间 -> 内核中套接字缓冲区 -> TCP 内核协议栈 -> 网卡” 这样的路径进行传输

```
sock_fd = socket(AF_INET, SOCK_STREAM, 0);
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(PORT);

if (connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
    perror("connect failed");
    exit(EXIT_FAILURE);
}

if (send(sock_fd, message, strlen(message), 0) == -1) {
    perror("send failed");
    exit(EXIT_FAILURE);
}
close(sock_fd);
```

##### accept函数

accept 函数会从队列头部取出一个已经完成三次握手的连接条目，创建一个新的套接字用于与该客户端进行数据通信，并将该连接从全连接队列中移除

```
conn_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);
	accept内部：
		看全连接列是否为空，若为空，且阻塞式socket，挂起当前线程
		否则从队列中取出一个连接
		创建一个新的套接字描述符。并非简单调用socket()，现在是在内核区，而这是一个用户区函数
		将客户端的地址信息复制到 addr 所指向的结构体中，并更新 addrlen 的值
		返回新的套接字描述符
```

- 参数解释：
  - `listenfd`：监听套接字的文件描述符，这个套接字是通过 `socket` 函数创建，并通过 `bind` 函数绑定到指定的地址和端口，再通过 `listen` 函数开始监听客户端连接请求的。
  - `client_addr`：指向一个 `sockaddr` 结构体的指针，创建初始化后，传到函数内部，用于存储客户端的地址信息，包括 IP 地址和端口号。
  - `client_addr_len`：指向一个 `socklen_t` 类型的变量的指针，用于指定 `addr` 结构体的长度，在函数返回时，该变量会被更新为实际存储的客户端地址信息的长度。

- 返回值：
  - 如果函数调用成功，会返回一个新的套接字文件描述符，这个新的套接字用于和客户端进行数据传输。原来的监听套接字 `sockfd` 继续保持监听状态，等待其他客户端的连接请求。
  - 如果调用失败，返回 -1，并设置相应的错误码。

##### 如果没有accept

三次握手只是在网络**传输层**确立了连接，应用层没法直接收发，需要有一个内核和应用之间的接口（socket），通过该socket进行read

如果没accept，三次握手正常进行，全连接队列正常存入相关信息，已连接socket正常创建，但应用层无法获得socket相关句柄，收到的数据停留在socket缓冲区，无法被应用读取

同时，因为没有使用accept从全连接队列取出，队列堆满，后续连接完成三次握手后无法加入队列，回复rst给客户端。

同时，内核可能会将超过一定时间未被accept的连接视为超时并主动关闭它们，同时发送 RST 包给客户端

#### mmap，sendfile，零拷贝

正常 read+write 两次系统调用(四次上下文切换)，两次DMA拷贝，两次CPU拷贝

​	从磁盘拷到内核（dma），内核拷到应用（cpu），然后应用拷到socket缓冲区，socket缓冲区拷到网卡，4次上下文切换，两次cpu拷贝

mmap+write：代替read，减少一次cpu拷贝

​	mmap：memory - map，内存映射，让应用像访问自身内存一样访问内核数据

​	把内核数据映射到应用(实际仍在内核，但应用区可读)，可以减少一次拷贝，但仍涉及两次系统调用

​	read类似于要把内核区数据拷到应用层，mmap直接用了个映射，虽说也是操作自己的空间，但会指向内核真实数据区。之后再执行write

sendfile：就是一种零拷贝，一次系统调用，一次cpu拷贝

​	如果网卡支持SG-DMA，只需将**缓冲区描述符和数据长度**传到 socket 缓冲区，就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，这样完全不需要cpu拷贝，是真正的零拷贝

#### pageCache：

零拷贝一定有pageCache，但不是所有文件收发都会用到pageCache（数据库用，kafka用）

如： 网卡 → ringbuffer → 某个具体内核 Socket → 用户空间 更为常见，

文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是磁盘高速缓存（PageCache）

即把磁盘中一部分数据存到内存，具体存什么？局部性原理实现预读+缓存最近被访问的数据

![image-20250217205116750](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20250217205116750.png)

#### 文件描述符

每一个进程都有一个数据结构 `task_struct`，该结构体里有一个指向「文件描述符数组」的成员指针。数组的内容是一个指针，指向内核中该进程所有打开的文件的列表，数组的下标就是文件描述符，是一个整数，也就是说内核可以通过文件描述符找到对应打开的文件。



#### **补：**

网络性能指标：带宽、延时、吞吐率、pps

查看网络配置：ip、ifconfig
 内容包括：IP 地址、子网掩码、MAC 地址、网关地址、MTU 大小、网口的状态以及网络包收发的统计信息

查看协议栈里的信息：socket信息，网口，路由表：netstat、ss

收到的数据包被修改了怎么办：本身有校验和（不提供加密和身份验证），被修改了直接丢，数字签名（私钥加密，公钥解密确保消息来源），tls加密，摘要算法进行完整性检查，

**长链接和短链接的互相转换**

？

**如何衡量网络性能**

网络性能：带宽（链路的最大传输速率），时延，吞吐率（单位时间成功传输的数据量）PPS（单位时间传输包的数量）

吞吐量：io多少字节

吞吐率：完成多少任务

### todo

#### http连接池是咋回事
