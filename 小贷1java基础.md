文件描述符：是应用程序与内核交互的接口,它为应用程序提供了访问文件资源的抽象。 	

动态代理：运行期间动态创建某个接口的实例

类实现多个接口（手机既要有录音功能，也要有播放功能）具有多个功能

垃圾回收器线程



**对象创建过程**

对象实例储存在堆内存中，变量保存对象的引用，也就是堆内存中的地址
TreeNode node1 = new TreeNode(3);
1.在堆内存中分配空间-----2.调用构造函数初始化对象-----3.将新对象的引用返回给变量

**utf-8 unicode什么区别**

Unicode是一种字符集，它定义了每个字符对应的唯一编码值，包括文字、符号、数字等，是一种定长编码。如（A:0041 Z:005A）

具体方案有是UTF-16和UTF-8。（8指8位也就是一个字节）

utf-8是变长编码，使用1到4个字节来表示一个字符，能节省空间。ASCII字符（U+0000至U+007F）只需要一个字节表示，而大多数常见的拉丁字母、数字、标点符号等字符也只需要一个字节。表示Unicode字符集中的所有字符，但对于一些较大的字符，需要多个字节表示。utf-16用16位（2字节）来表示一个字符，每个字符都固定使用 16 位来表示

一般编码用编码用utf-8存

补：java中的char和c中的不一样，redis想存一个string = “你好”，1.首先unicode得到 '你'的码点是U+4F60和'好'的码点是U+597D，

2.然后将其对应utf-8（节省空间） 0x4f60对应UTF-8序列0xE4 0xBD 0xA0; 0x597d对应0xE5 0xA5 0xBD。得到六个字节，

3.存入字符数组: ['你','好'] = [0xE4, 0xBD, 0xA0, 0xE5, 0xA5, 0xBD, **'\0'**]

# java基础

**jdk，jre，jvm**

jdk（development kit）开发工具包，给开发人员使用的，包含开发程序所需要的一切工具，bian'yi

jre(runtime environment) 运行环境，包含虚拟机，必要的类库等

jvm：虚拟机，把编译出来的字节码文件，**解释**成具体系统平台上的机器指令，让其在各个平台运行

**final**：方法不能被重写，类不能被继承，字段不能修改，类似常量的感觉，声明或定义时就得赋初值

**static**:例：工具类的静态方法创建线程池

**super**：调用父类的被覆写的方法

**区分空值null和空字符串""?**null不是一个对象，不能调用任何方法字段，指向一块非法内存（代码段下面）

**java的基本数据量型**(8种)

整数：short2字节，int4字节，long8字节》

浮点数：float4字节，小数点后七位，double8字节，后15位》字符：char2字节 》布尔：1字节

**补：浮点型的存储方式，以及浮点型怎么表示数的**

小数转二进制：乘2取整。计算机用浮点数表示，浮点表示小数点的位置可以变化，

所以首先把小数转换成科学计数法1.a*10^b，然后float用1位标识符号位，8位标识指数位，23位标识小数位

double则是，1位符号，11位指数，52位小数，`log10(2^53)` 约等于 `15.95` 和 `log10(2^24)` 约等于 `7.22` 位（为什么是7和15位）

具体储存的话，首先转二进制，整数部分小数部分都转，然后移动小数点，变成科学计数法，得到指数位，然后加上**偏移量**得到需要储存得整数（偏移量是因为有符号整数计算麻烦）

**BigDecimal**

可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

**什么是面向对象**：把整个程序运行过程抽取出一个个对象，对象有自己的属性和行为，然后去让对象解决问题，耦合度较低，面向过程就是抽取出一个个函数，按流程去做事，耦合度高，可维护性可复用性可扩展性较差，不适合大型项目。优点是自顶向下编程，便于理解，适合解决，简单，逻辑性强的问题**（将数据和操作数据的方法封装在一起，形成一个类。）**

**封装：**公有的get、set方法，私有的对象属性，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。使用访问修饰符（public、private、protected），隐藏内部实现细节

**继承：**使用已存在的类作为基础建立新类的技术，新类可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

**什么是多态**：(是什么，解决了什么问题，怎么实现)

1.允许不同的对象对同一个方法做出不同的响应，即使用统一的接口操作不同的对象，一个声明类型，一个实际类型（父类的引用指向子类的实例。）

2.代码复用（通用的接口处理不同的对象），可扩展（添加新类型，只需要保证实现同样的接口），接口统一（客户端不需要关注具体类型），只需要知道接口的定义

3.继承实现（子类对象被当作父类对象调用）接口实现（声明类型是接口，实际调用是实现类）

**抽象类和接口的区别？**

相同点：都不能直接实例化，需要继承和实现，单继承和多实现，多实现间接实现多继承

不同点：接口：抽象方法，不能有实现，可以有deafult，成员变量只能是public static final（静态常量）（静态的，属于类，多实例共享）（不可被修改，必须初始化）用于**不同类的解耦**和多态性实现

抽象类：可以有方法定义和方法实现，可以有实例变量（对象的属性）和静态变量（类的属性），一般是**类的一个模板**（基类），供其他类继承和扩展使用，不能用final修饰（必须要继承），提供一个类的模板

负载均衡接口定义了一个select方法，abstractBalance实现了这个接口，又定义了一个doselect抽象方法，select会调用doselect，randomBalance继承了抽象类，隐式继承了select方法，重写了doselect方法

补：**super**调用父类的方法，即使被覆写了也能调

**equals 与==区别**

==判断基本数据类型值相等，引用对象地址相等，

equals只能比较对象，没重写比较地址，重写比较内容（一般为比较类的属性是否一致），`String` 中的 `equals` 方法是被重写过的

**为什么要有hashcode**

用于快速判断元素在哈希集中应存放的位置，如果发现hashcode相同，再用equals判断对象是否真的相同，减少equals次数，提高执行效率

**为什么重写 equals() 时必须重写 hashCode() 方法？**

equals代表两个对象相等，内容相同的对象在哈希集合中的位置必须相同，所以hashcode必须相同。

存map时，先算hash相等再用equals判断是存在链后面还是别的位置，**例：**重写hashCode方法：return 31*name.hashCode()+age

**String、StringBuffer、StringBuilder 的区别？**

String是不可变类型，频繁改变不应该用String，会消耗资源。

字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个新的 `String` 对象 

Stringbuffer 线程安全，builder不安全

**为什么String是不可变类型**

底层用char[] 储存，被标记为private final，同时String类也被标记为final，导致其不能被继承，避免子类破坏不可变性（子类重写父类方法，创建声明对象父类，实际对象子类，调用方法调用的是子类的）

补：后改用byte[]储存字符串，char2字节，byte1字节

**异常**

throwable分exception和error

Exception分Checked(受检查异常，必须抛，FileNotFound)和Uncheckd(空指针，数组越界，参数错误)

Error包括OOM，StackOverflow等

try-with-resources：适用于必须关闭的资源，防止泄漏，正常写在finally中，调用close

**手写一个泛型类**

泛型是指允许在、接口、方法定义时使用一个类型参数，实现代码通用性，可读性，避免了重复编码和强制类型转换，同时在编译时提供类型检查，因此更安全

```
public class MyGeneric<T> {   
     private T data;    
     public MyGeneric(T data) {
        this.data = data;    
     }     
	public T getData() { return data; }     
	public void setData(T data) {this.data = data;    }
}
Generic<Integer> genericInteger = new Generic<Integer>(123456);
```

**反射：**在程序运行时动态的获取类信息，包括字段，方法，构造函数等，并创建对象实例，可以用于运行时根据需要加载外部的类和资源，实现插件化结构，也可以用于检查注解，泛型等信息（创建对象，调用方法，访问字段）

框架中大量使用动态代理，动态代理基于反射，注解的实现也用到了反射

**注解**：是一种特殊的注释，需要解析才能生效，解析方法有两种，**编译器直接扫描**@Override

或**运行期间通过反射处理**@Value@Component，扫描指定包路径，找到带有特定注解的类@Componet，实例化成bean

**自定义注解**：使用@interface定义，定义作用域，生效时间，定义字段和默认值，使用时通过反射解析注解信息

**SPI和API**：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。

实现方提供接口和具体实现，调用方直接调用，这就是API

当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。**缺点：**要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。

有点像策略模式，不修改客户端代码的情况下，动态地替换服务实现，如日志，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了。加载进来哪个包就用哪个

**序列化和反序列化**：对象变为二进制字节流，用于网络传输或存数据库存文件。对应七层协议的**表示层**

### jdk源码

**集合概述**

collection接口下有list，set，queue，map四个接口

**ArrayList和Array**

是动态数组和静态数组，能否扩容，泛型保证类型安全，只能存对象

补：ArrayList扩容，无参构造传入空数组，第一次插入后扩容为10（最小容量），有参构造看是否小于10，不是就按指定的来，然后超过容量之后扩容为1.5倍，size+size>>1

**List的实现类**

ArrayList、LinkedList、Vector、stack

1. ArrayList：基于动态数组实现，优势在于支持随机访问和快速插入/删除元素，适用于频繁读取和遍历的场景。（不安全）
2. LinkedList：基于双向链表实现，内存不连续，优势在于支持快速插入/删除元素，适用于频繁插入/删除元素的场景。（不安全）
3. Vector：和ArrayList类似，但由于其**线程安全性**，适用于多线程环境。
4. Stack：基于Vector实现，是一个后进先出（LIFO）的数据结构，适用于需要按照后进先出顺序处理元素的场景。

一般用ArrayList更多，因为支持随机访问，同时link插入删除也没快到哪去，因为需要遍历找到位置

**List和Set的区别？**有序无序，可否存放重复元素

list按插入顺序保存，需要保持元素顺序，会储存重复数据，通过索引值直接访问、插入或删除元素，适用于需要频繁进行这些操作的场景用list

不关心顺序，需要去重，快速判断元素是否存在，需要交并补等集合运算用set

**hashtable和hashmap区别是什么？**

hashtable线程安全，所有方法都加了synchornize，同一时刻只能由一个线程操控该对象，所以效率比较低，已经几乎不用了，用ConcurrentHashMap

**HashMap和CurrentHashMap的区别**

current线程安全，使用了分段锁，一次只锁需要操作的那一部分（**已经修改了**，现在的结构是node数据+链表/红黑树），对node数组加优化后的synchornize（只锁首节点），（线程不安全主要就是因为哈希冲突）

**补：**linkedhash：按插入顺序排序，treemap：按key的顺序排序，用**红黑树**实现，根黑，叶黑，根到叶的最长路径不会超过最短路径的两倍

**补：**hashmap插入删除和查询的复杂度O(1)，treemap复杂度O(logn)， 元素稀疏且无序时用hashmap，元素稠密且有序时用treemap

补：初始化通过cas实现线程安全

**HashMap底层怎么实现的 ？线程安全吗？**（拉链法）

HashMap底层是基于数组和链表实现的。HashMap将key通过hash算法映射到数组中，然后在对应的链表中查找value。当多个key的hash值相同时，会在同一个数组位置上使用链表来存储这些key-value。但是，当链表长度太长时，会影响HashMap的性能，因此在JDK1.8中，当链表长度超过阈值时，会将链表转换为红黑树，以提高查找效率。

HashMap不是线程安全的，因为多个线程同时访问HashMap时可能会导致数据不一致的问题。可以使用ConcurrentHashMap来实现线程安全的Map。（1.put涉及到计算哈希值，计算位置，完成插入等多个操作，不是原子操作2.扩容涉及到重算哈希值，重算位置，复制等 步骤，可能多线程同时扩容3.链表转红黑树是非原子的4.读写冲突，一个线程put一个线程get）

**HashMap插入一个元素的过程**

根据key的哈希算应该在table的哪个位置，看该位置是否为null，为null新建节点并插入；否则看table[i]的首个位置的key和要插入的是否一样（hashCode和equals都得一样），一样覆盖val，不一样一直往后找（数组或链表），都不一样就插入节点，然后根据容量，负载因子和当前元素数量是否需要扩容

**扩容的时候数据是怎么迁移的**

扩容都是翻倍扩容，所以用原先位置key的hash值与旧数组的长度（oldCap）进行&运算，为0则不用动，为1的话新位置等于**原位置+原数组长度**

补：下标计算是(n-1)&hash，所以翻倍扩容

**HashMap源码**

初始容量默认16，可以传入初始容量参数，然后设置为大于他的2的n次方

容量（n-1）&（hash（key））计算储存位置，哈希桶中用数组或红黑树（链转树）

**扰动函数**：减少哈希碰撞，原哈希码^原哈希码右移16位

初始化容量：比所需存放元素大的最小的2的n次方

**负载因子**：默认0.75，超过多少扩容，所存元素/容量

扩容方法：二倍扩容，高位多了一位1，原哈希值与扩容新增出来的长度16，进行**&运算**，等于0下标不变，等于1在原来的位置+16

**链转树：**桶容量大于64，链长度大于8，两个条件都满足

**TreeMap**：哈希map遍历Key时，其顺序是不可预测的。而treeMap底层是红黑树，按key进行排序，增删查的复杂度都是logN，同时他不需要使用hashcode，但是需要重写一个Comparator，负责比较传入的两个元素`a`和`b`，如果`a<b`，则返回负数，通常是`-1`
或是在key中重写ComparateTo方法

**HashSet 如何检查重复?**

底层是hashMap，先算code，没有一样的认为唯一，有的话再用equals方法

**红黑树是什么？**

二叉查找树可能退化成链表，严格的平衡树插入删除的过程可能涉及到复杂的树的变化，影响查找效率

红黑树是自平衡的二叉查找树，增删改查效率稳定olgn，满足1.根节点黑色，叶节点黑色2.红节点的两个子节点是黑色3.任意节点到叶节点的路径包含相同数目的黑色节点

补：红黑树主要用于在内存中维护有序的动态集合（epoll），而B树和B+树主要用于实现外存储的索引结构，例如数据库和文件系统。

**阻塞队列，优先级队列，延迟队列**

阻塞队列：生产者消费者结构；优先级：堆；延迟队列：底层是优先级+ReentrantLock保证线程安全

**String**是不可变的类型，也不能被继承，StringBuffer是线程安全的，使用了synchornize关键字，StringBuilder单线程下效率更高

**lambda(parameters) -> expression**

(参数列表) -> 表达式或代码块。参数列表描述了输入参数，可以省略类型，甚至括号。箭头符号将参数列表与表达式或代码块分隔开来

```
public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) {
```

返回一个比较t类型的比较器，需要传入一个函数，函数接收t或者t的父类，返回比较器需要的键（比较器根据键确定排序位置）

```
Arrays.sort(intervals, Comparator.comparingInt(interval -> interval[0]));
```

```
Arrays.sort(intervals,(a,b)->(a[0]-b[0]));
```

**怎么理解Java里面的双冒号“::”**

双冒号"::"是方法引用，会根据上下文推断参数类型，因此特别适用于直接引用已有方法的情况。

方法引用的一般形式是：ClassName::methodName

**tomcat的运行原理**

用户发起请求，访问tomcat注册（监听）的端口，监听线程创建socket连接，已连接socket接收到数据去线程池拿一个线程执行用户请求，这个线程会带着封装好的request，去调用我们开发的webAPP（controller service dao）再访问数据库

**（Integer a=null; System,out.println(a==127) 会报错吗 原因 拆箱使用的函数 底层细节**

会报npe，因为integer会自动拆箱，然后调用intValue方法

**Integer是包装类，int到Integer的转换称之为装箱**

Integer.valueOf(int) ，-128~127之间会用缓存，得到同一个对象，之外会用new，new一定是创建了一个新的对象

new Integer(int)，new会调用构造方法，把int赋值给一个final的属性，得到一个新的对象



