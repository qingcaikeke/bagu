**什么是公平锁和非公平锁？**

公平锁按申请锁顺序获取锁，先到先得，能避免线程饥饿，但是需要维护线程队列，效率会更低一些

非公平锁按随机顺序获得锁，都可以竞争，可能导致线程饿死

**创建3个线程打印按序abc**

实现runnable接口，任务接收的参数有字符和id，分别创建3个线程，加锁，给个count计数，只有count取余3等于id的时候才能打印

### 并发编程

**java的线程和操作系统的线程有什么关系**

java线程是由Java虚拟机（JVM）管理（创建、销毁）的，会映射到操作系统线程，会利用操作系统的线程调度和同步机制。

**线程创建的方法**

1.继承thread类，重写run方法 2.实现runnable接口，重写run方法，作为参数传入new thread（）构造函数 3.实现callable接口 ，作为参数传到FutureTask，然后用FutureTask创建线程 3.线程池ExecutorService 4.匿名内部类（和runnable差不多）

本质上其实只有一种方法，new thread() .start()

补：不能直接 thread.run()，会被当成main线程下的一个普通方法执行，而非多线程，而start()会使线程进入就绪态，等分到时间片后，自动执行run方法下的内容。

补：线程只是实现Runnable或实现Callable接口，还可以继承其他类。这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。

**线程状态**

waiting：object.wait() thread.join()

time_waiting:thread.sleep(long),object.wait(long),thread.join(long)

blocked：synchornize获取锁失败，wait被notify后重新获取锁失败

**sleep() 和wait()**

sleep() 是thread的方法，不会释放锁，wait主要用于线程间通信，sleep用于定时任务或简单等待。

而 wait()是object的 方法，在同步代码块中调用，会释放了锁 。wait之后不会自动苏醒，需要notify，notify之后重新进入synchornize代码块，需要重新获得锁，否则

join():写在t2的runnable中，t1.join(5000)，表示t2等待t15s，或不指定时间，t2等待t1执行完成

**volatile关键字作用，具体怎么做到可见性？**（单例模式用到）

volatile关键字是Java中用来修饰变量的关键字，它的作用是保证变量的**可见性**和禁止指令重排序。但是volatile**不能保证原子性**

一个线程修改了共享变量的值，其他变量可以立刻看到这个修改

可见性：线程1对属性修改，线程2能及时知道并作出反应，具体而言，线程1修改cpu内存的值，强制刷新到主存，线程2强制自己的cpu内存失效人，然后获取最新值（禁用cpu缓存）

重排序：为了提高程序执行效率，**编译器和处理器**可能会对指令进行重新排序。但是，如果一个变量被volatile修饰，就禁止了指令重排，确保每个线程都能看到正确的操作顺序。**举例**：单例，如果重排序 1.分配内存 2.初始化 3.指针指向 如果23重排序就可能导致空指针

通过使用**内存屏障**的机制禁止重排序。

当一个线程对volatile变量进行写操作时，会在写操作之后插入写屏障，将最新的值刷新到主内存中。当其他线程对该变量进行读操作时，会在读操作之前插入读屏障，从主内存中获取最新的值。（所有写操作在写屏障之前完成，读操作在读屏障之后完成）

**java中有哪些类型的锁**

乐观悲观，读写，公平非公平等

synchornize，reentrantlock，读写锁（ReentrantReadWriteLock），cas乐观锁

乐观锁和悲观锁区别：是否认为共享资源会经常承受并发，读多还是写多

**synchornize**

是可重入锁（通过计数器实现），是隐式锁（自动加锁和释放锁），一个线程进入syn代码块，会尝试获取对象或者类的内置锁，如果没被占用，就成功获取，对象头中有两个相关标记位，偏向锁标记位和锁状态标记位

补：**和volatile的区别**：syn是用于线程同步的，保证互斥的访问共享资源，能保证**可见性和原子性**，volatile是修饰变量的，保证可见性（读变量时强制从主存读取，而不是从线程的工作内存读取），不能保证原子性，也不会阻止并发访问，但是性能更好，比方说两个线程同时执行++，然后写回到内存，有一个可能会被覆盖，因为i++不是原子操作（包含读，改，写回），虽然线程a读了值，没改，阻塞了，线程b读值，然后a改了，写回，但是这时候b读值的操作已经完成了，并且读的对当时来说是新值，然后直接执行改，写回，这样两个线程就有一次操作被覆盖了

补：每个线程都有自己的缓存空间，对变量的操作都是在缓存中进行的，之后再将修改后的值返回到主存中

补：怎么实现可重入的：有一个计数器，如果发现当前申请加锁的线程和持有锁的是一个线程，就把计数器+1，count减少到0就释放，owner指向null

补：**和reentrantlock区别：**两者都是可重入锁底层实现：synchronized 是一个关键字，是在JVM层面通过监视器实现的，而 ReentrantLock 是jdk层面的,能看到她的源码，他是基于AQS实现的，除此之外：显示锁，隐式锁，公平锁。

**synchronized锁优化（锁升级）**（无锁，偏向锁，自旋锁，重锁）

目的：希望花费最小的代价达到目的 ------- 补：对象头包括**锁状态，哈希码，垃圾回收信息**

**偏向锁**：线程进入同步块时，如果发现之前没人加过锁，会将**线程id标记在锁对象**头上，并标记为偏向锁，如果新线程想获取锁，如果发现锁对象有偏向锁标记，就判断持锁对象是否为当前线程，是的话直接获取锁，不是则升级为轻量级锁

为什么偏向锁要升级成自旋锁：如果不升级，多线程就变成串行执行了，所以说是为了防止a一直持有锁不放的情况

**自旋锁**（轻量级锁）：尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，避免线程频繁地进入和退出阻塞状态，以减少线程切换的开销（上下文切换，用户态内核态的切换）。自旋次数有限制，超过一定次数后如果还未获取到锁，线程会放弃自旋，转而进入阻塞状态，避免占用过多的CPU资源。

**ReentrantLock**

是可重入锁，是显式锁，实现了lock接口，使用之前需要先创建 ReentrantLock 对象，然后使用 lock 方法进行加锁，使用完之后再调用 unlock 方法释放锁，可以创建**公平锁**（队列实现，公平锁多了一个判断是否有线程在排队的判断，否则直接CAS），可以实现轮询

**AQS:**是一个抽象类，提供共享锁和排他锁的实现

AQS的核心思想是使用一个状态变量来控制同步器的状态，同时维护一个等待队列来管理等待获取同步资源的线程。状态变量会通过cas更新

**CAS**：核心原理是基于硬件层面的原子性保证，新值写入内存时，比较内置值是否与**预期原值**相同，缺点是会有aba问题和开销问题（会一直轮询）

**还有哪些地方用了CAS**

AtomicInteger原子类，锁ReentrantLock等，并发容器ConcurrentHashMap

**分段锁**

concurnent hashmap用了分段锁，共享资源被分成多个段或者区域，每个区域都有一个对应的锁。多个线程需要同时访问资源的不同部分时，它们可以并发地进行，因为只需要获取该区域对应的锁，而不是整个资源的锁。优点是提高并发性能，减少锁竞争的激烈程度，缺点是管理多个锁的复杂性。

**滑块锁**

和分段锁差不多，不过更高级，会根据当前的并发访问情况来动态地调整滑块的位置和大小，以最大程度地减少锁竞争。

会采用一些策略来决定何时以及如何调整锁的粒度。这些策略可以基于一些指标，如锁竞争的程度、线程的等待时间等。

[关于线程池在生产环境中的使用 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzkyMTM4MjI0OQ==&mid=2247484259&idx=1&sn=3c29de8daf9d470db3eec400235d6aea&chksm=c1853f65f6f2b673e5b5cc777019705420d5d93320d5dfcc08f65538d4abfb5116d75da128da&scene=21#wechat_redirect)

**线程池作用**

减少创建销毁线程的开销，高并发提供响应速度（不用等待创建），可以通过线程数量控制并发度，统一管理资源，提高利用率

**线程池中核心线程数量大小怎么设置**

cpu密集型线程数+1，防止过度切换，io密集型，可以2*cpu个数，多来几个，实际中需要测试找到一个理想的值

**线程池创建的几个参数**，线程池原理：讲一下这个流程就行

1.核心线程数2.最大线程数3.等待时间4.时间单位5.任务队列6.线程工厂7.拒绝策略

线程名称：重写了线程工厂，主要是 `为了线程的命名规范` ，这样在查询日志时，只要做好业务之间的隔离，就可以很容易的根据线程名称来定位到对应的业务，便于分析线上问题

**线程实现类（线程池）**ExecutorService es = Executors.newFixedThreadPool()，内置api

```
ThreadPoolExecutor pool = new ThreadPoolExecutor(3,6,60,s,任务队列，Executors.defaultThreadFactory())
```

FixedThreadPool：核心线程数等于最大线程数，线程池中有空闲线程就立即执行，没有就放到任务队类，适合任务执行时间较短的情况

CachedThreadPool：线程数可以无限增大，同时闲置时对线程回收（从缓存中移除），即线程池中的线程数不是固定不变，任务队列不储存任务，只负责中转，所以效率比较高，适合任务执行时间较短、任务数不确定。或即时任务，需要尽快完成

SingleThreadExecutor：使用唯一的线程取执行任务，保证任务按提交顺序依次执行

ScheduledThreadPool：可以设置定期的执行任务，比如每隔 10 秒钟执行一次任务

SingleThreadScheduledExecutor：只有一个线程，定期的执行任务

补：利用Executors的静态方法都可能oom，fixed和single都用的无界的阻塞队列，schedule用的无界阻塞队列，cached允许无限创建线程

补：阻塞队列，有一个最大容量，队列为空时会阻塞获取元素的操作，或在队列已满时会阻塞添加元素的操作。底层用了ReentrantLock

补：阻塞是指线程在执行过程中暂时停止，并且不会消耗CPU资源，直到某个条件满足或者等待时间到达。

**线程池的类型**

newCachedThreadPool ：无限创建

newFixedThreadPool ：固定大小的

newScheduledThreadPool ：单线程的

newSingleThreadExecutor：定时任务

补：一般不同的业务使用不同的线程池，避免非核心业务对于核心业务的影响，一般非核心业务执行慢，核心业务在任务队列中等待，拿不到线程执行；父子任务同用一个线程池可能死锁，父把核心线程全用完了，子没有线程可用，父也无法提交

# jvm

**为什么要了解？**

java是由虚拟机自动管理内存的，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机的内存分布，，排查问题会是非常困难的。

当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节

**需了解** GC分代回收的思想和依据以及不同垃圾回收算法的回收思路和适合场景

[理想汽车二面：说说一个java文件从加载到执行的过程，运行时数据区域的划分 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzU0OTkxNzA4Mw==&mid=2247483923&idx=1&sn=b8fa31d6d4e42720f77e123d44a7212a&chksm=fba9dae7ccde53f1eed54a8db36c74d6dba8043464ad4fe4866f16ed2a7b14f6d9a8f5faeba8&scene=21#wechat_redirect)

[米哈游二面，反复考察的类加载器，竟然这么简单 (qq.com)](https://mp.weixin.qq.com/s/mRhKxvgUlmU_RtnGPYsvng)

**为什么java跨平台性能好**

JVM从软件层面屏蔽了不同的操作系统在底层硬件和指令上的区别，针对同一份HelloWorld.class文件，JVM会根据不同的操作系统分别生成其对应的机器码。

**java的对象分配规则（对象怎么创建）**

类加载--验证--准备（默认值）--初始化（静态变量，代码块）--创建对象（分配空间--设置对象头---执行构造方法）

先看类是否被加载过，申请内存，赋默认值，再对属性赋初始值，最后将对象的引用地址赋值给变量

1.内存空间分配，一般堆内存（可能在栈中，涉及逃逸分析，对象的引用不会逃逸到方法调用栈之外，即不会被其他线程引用或返回给其他方法）

2.分配对象头，包括一些对象的元信息，如**哈希码，锁状态，垃圾回收信息**

3.零值初始化，所有成员变量初始化为0值

4.构造函数调用，初始化对象

5.返回对象引用

**对象在堆中的储存布局**

8字节的markword对象头（用于存储对象的元数据信息，如对象的哈希码、锁状态、GC标记等）

4字节的classpoint，指向T.class对象的指针。

成员变量 						对齐填充（对象大小必须是8字节的整数倍）

**类加载过程**(JVM上运行如何处理class文件)+

1.根据全类名找到字节码文件，方法区分配内存，类加载器把字节码加载到内存，创建一个class对象储存类的元数据

2.验证字节码文件；为静态变量分配内存，赋默认值；把相关的方法或字段转换为直接引用（内存地址），以便快速访问

3.执行类的初始化代码，为静态变量赋初值，执行静态代码块。同时，JVM会保证类的初始化是线程安全的。

补：类加载器把class加载到内存，class对象在方法区，指向class文件，实例对象在堆，指向class对象

补：代码执行过程 编译成class--类加载器加载---运行时数据区储存信息---执行引擎执行代码（开启main线程）

**双亲委派机制** （什么时候加载一个类）

首先jvm是动态加载（懒加载）由类加载器把class文件加载到内存

自底向上**检查**该类是否已经被加载，自顶(父类)向下进行实际查找和**加载**。

当一个class文件需要被加载到内存时，首先调用自定义加载器，检查是否被自己加载过，记载过直接返回class对象，如果没有，调用父类加载器判断，一直推到顶层加载器Bootstrap，如果还是没被加载过，则调用findClass方法查看自己的加载范围，判断类是否属于该范围，如果是就自己加载，否则向下抛给子加载器

目的是为了**避免重复加载，保证类的唯一性和安全性**。不同的类加载器加载相同的类，也会被是为不同的类，因为每个加载器都有自己的类命名空间，可以防止系统类库被篡改或替换，因为即使有人尝试加载一个与系统类库同名的类，它也不会覆盖系统类库。

补：类加载器是组合关系不是继承关系。双亲委派可以被打破，在某些应用服务器中，为了实现热部署（即不重启服务器就能更新应用程序）会使用特殊的类加载器来加载和卸载类。

**四种类加载器，具体都是干嘛的**

启动类加载器（**Bootstrap ClassLoader**）：它是JVM的一部分，用于加载Java核心类库，如java.lang中的类（object,thread,string,system）,他们使用本地代码(c++)实现的，不是Java类，因此在Java中无法直接获取对其的引用。

扩展类加载器：它是由Java实现的。

应用程序类加载器(App ClassLoader)：也称为系统类加载器，负责加载应用程序classpath下的类。

自定义类加载器：用户可以根据需要创建自己的类加载器，以加载特定位置或方式的类文件。

**JVM内存模型（运行时数据区）：**+++

线程独占：程序计数器、虚拟机栈，本地方法栈， 线程共享：堆，方法区

**程序计数器**（下一条要执行的指令的地址）：字节码的行号指示器，用于选取下一条要执行的字节码指令，实现顺序，分支，循环，异常处理等操作，没有oom

补：native方法：本地机器代码实现的计算机程序方法（常指c++），而非高级程序语言，用以提高性能与底层系统交互

**虚拟机栈**（函数上下文，局部变量）：为虚拟机执行 Java 方法 （也就是字节码）服务，每个线程对应一个栈，每个栈有多个栈帧，每个方法一个栈帧，储存方法的局部变量表，返回地址等

**本地方法栈**（和虚拟机栈一样，但是为本地方法服务）则为虚拟机使用到的 Native 方法服务

可能出现`StackOverFlow`栈内存不允许动态扩展，请求深度超过栈最大深度，或`oom`，可以动态扩展，扩展时无法申请足够的内存空间

**堆**（储存对象实例）：jdk1.7之后默认开启逃逸分析，如果某方法的对象引用没有被返回或被外面使用，可以直接在栈上分配内存

是垃圾收集器的主要管理区域，因此也叫gc堆，通常被分为新生代（**eden、from survivor、to survivor**）（1/3堆内存），老生代（2/3），元空间（直接内存区域），是出现oom错误的位置

**方法区（元空间）**：储存已被虚拟机加载的**类的加载信息及元信息，常量池，静态变量，方法字节码**（字符串常量池在堆空间，运行时常量池在方法区，方法区元空间实现）内存大小受限于操作系统为java虚拟机分配的逻辑内存空间。

补：类的元信息类（存在方法区）类的名称、访问修饰符、父类、实现的接口

**新生代和老年代**

多数情况下，对象在eden区分配，没有足够空间时，发起一次Minor GC，内存不够时通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，就进入survivor，年龄置为1，之后每经历依次minor GC，年龄+1，年龄增加到一定程度（默认15）就进入老年代

大对象（需要大量连续内存空间的对象，如：字符串、数组）直接进入老年代

当进行垃圾回收时，虚拟机会按照对象的年龄从小到大对其所占用的空间进行累积。当某个年龄组的累积大小超过了Survivor区的一半时，系统会考虑提升这个年龄组的对象到老年代。提升的年龄阈值是由当前年龄和配置中的`MaxTenuringThreshold`中较小的一个确定的。

**JVM异常问题？**

StackOverflowError（线程请求栈深度超过虚拟机所允许的最大深度）

OutOfMemoryError（堆内存不够用）（1.花很长时间执行垃圾回收只能回收很少的堆内存 2.创建新对象时，堆空间不足以存放新对象）

PermGen space（方法区内存不够用）

**怎么找到需要回收的垃圾？**死亡对象判断方法

一个对象没有任何引用指向它，他就会被回收，这个过程由JVM的垃圾回收器自动完成。

引用计数器，**可达性分析**算法（从GC Roots对象开始，通过一系列的引用链来遍历所有的对象，如果一个对象不可达，则说明它已经死亡，可以被回收了）

**垃圾回收算法有哪些？**

标记清除法、标记整理法、复制算法、分代收集算法

1.会产生大量不连续的空间碎片

2.把所有存活的向一端移动，清理调边界以外的

3.分半区，浪费空间

4.新生代使用复制算法（每次大批对象死去，只有少量存活，复制成本低）

老年代使用标记清除算法或者标记整理（因为回收频率不高）算法

**有哪些常见的垃圾回收器，举几个说说？**

Serial收集器，ParNew（**Parallel并行**）CMS（Concurrent Mark Sweep）收集器，G1 收集器

1. Serial收集器：单线程的垃圾回收器，使用标记-复制算法，适合小型应用程序或客户端应用程序。
2. Parallel收集器：多线程的垃圾回收器，使用标记-复制算法，适合在后台运行的中型应用程序。
3. CMS收集器：并发垃圾回收器，使用标记-清除算法，适合对响应时间有要求的中型应用程序。
4. G1收集器：并发垃圾回收器，使用标记-整理算法，适合对响应时间有要求且堆内存较大的应用程序。

其中，Serial收集器和Parallel收集器是新生代收集器，CMS和G1是老年代收集器。

G1的出现是为了替换CMS，现在默认是CMS

**CMS和G1的区别**

CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用
G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用
