持久化 原子操作 异步复制

**介绍一下redis数据库？**

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是**原子性**的，因为执行命令由单线程负责的，不存在并发竞争的问题。

除此之外，Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。



Redis常见的**应用场合**有：

- 缓存
- 消息队列
- 排行榜或计数
- 消息发布和订阅
- 商品列表

**Redis五种基础数据结构及其底层实现**

**string（字符串,整数,浮点数），List（列表），Set（集合），Hash（哈希），Zset（有序集合）**，**map**

String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
List 应用场景：消息队列(如何保证消息有序，不重复，可靠性)，生产者需要自行实现全局唯一 ID，不能以消费组形式消费数据
Hash 类型：缓存对象、购物车等。
Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

底层：跳表（改进的多层有序链表）

补：SDS（简单动态字符串simple dynamic string）

补：常用指令 (set k y)(get k)(exist k)(strlen k)(del k)(incr k)(incrby k 10)(decr k)(decrby k 10)

(EXPIRE k 60 / SET k v EX 60)(TTL k)

(set lock_key unique_value EX PX 10000分布式锁，不存在就插入，过期时间10s)

补：pv访问次数（page view），uv(unique visitor)访问人数

**map怎么扩容，扩容时会影响缓存吗，渐进式rehash**

底层定义了两个哈希表，表一储存数据，表二没有分配内存，随着表一空间增大，触发rehash，给表2分配空间，大小为表1的二倍，把表1的数据迁移到表二，释放1的内存，最后把表二置为表一，1置为2。

为了防止阻塞，提出渐进式rehash，迁移工作分多次完成，每次增删改查的时候除了执行操作，还会考到表2上，保证1的数据只会减少，随着请求操作，最终把所有数据迁移到表二，增删改查会同时在两个表执行，如查的时候先去表1查，表1查不到去表2

补：是否触发通过计算负载因子：保存的节点数除以哈希表大小

**跳表结构了解吗，和二叉树有什么区别，从时间复杂度和空间复杂度分析**

链表查询复杂度on，查询效率低，所以产生了跳表，设计灵感来源平衡树

跳表是多层有序链表，底层包含所有元素，是双向链表

### 为什么用跳表而不用平衡树？

跳表空间复杂度更好，每个节点的指针数更少，维护更简单，范围查找更简单

**Redis里面的操作是原子操作吗，如何实现的**？

 单线程，支持事务，数据结构操作也是原子的（如：set key  value，给list push 元素）

**说说你对Redis操作原子性的理解**

redis是单线程模型的，命令的执行过程不会涉及线程切换，整个命令的执行不会被中断，要么全部执行成功要么全部失败

redis支持事务，在执行一些复杂操作时，可以将多个底层操作打包成一个原子操作，同时支持回滚，一些命令出错，会撤销已执行的

K) **Redis 是单线程吗？**（多核机器里使用会不会浪费机器资源？）

主要工作单线程（解析请求，进行读写），6.0之后，io处理多线程，**持久化，异步删除，集群数据同步**使用后台线程

Redis 单线程指的是主要工作是单线程，即「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的。支持高并发是因为结合io多路复用，一个线程监听多个socket（监听soc和已连接soc），通过事件循环函数
6.0之后采用多个io处理线程处理网络请求建立socket请求）

Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程的（持久化，异步删除，集群数据同步）

**Redis为啥单线程还这么快**（内存，单线程，多路复用）（处理io请求是多线程，命令执行是单线程）

内存存储、单线程模型、高效的数据结构、io多路复用，事件驱动的非阻塞

内存型数据库，读写快（性能瓶颈在内存和网络带宽，不在cpu，也就不需要多线程）。

单线程模型，简化并发控制，避免多线程竞争与同步开销（加锁解锁，上下文切换），没有死锁问题

非阻塞io结合io多路复用（epoll）处理大量客户端socket请求（一个线程处理多个io流）。

优化：批量操作，管道技术，减少了网络通信开销

补： Redis 6.0 版本之后，因为网络硬件能力提升，有时候redis的性能瓶颈为网络io处理，所以也采用了多个 I/O 线程来处理io请求，对命令的执行仍然是单线程

**那如何利用多核心？**docker部署多个redis

K) **Redis里的数据落地(持久化)机制**

（aof存命令，文件大，恢复慢，丢失少）（rbd存数据，文件小，恢复快，丢失多）

**AOF日志**：先执行写命令，再将执行的写命令追加到一个文件末尾    配置参数（内核写回到硬盘的时机，Always，Everysec，No）

优点：无需额外检查，不会阻塞当前命令执行    缺点：数据可能丢失，可能阻塞其他操作

具体流程：**日志写到aof_buf(用户区)->拷贝到page cache(内核中的磁盘高速缓冲区)->等待内核将数据写到硬盘**

**AOF重写**：避免AOF文件越写越大，在重写时，获取所有的k-v，用一条新命令记录到新的AOF文件。

具体过程：创建**子进程**（不是线程）避免阻塞，父子进程**共享内存**但只读，主进程修改时发生**写时复制**，创建独立的数据副本进行修改，

重写期间，redis执行一个写命令，同时将命令写到AOF缓冲区和AOF重写缓冲区，完成后像主进程发信号，将重写缓冲区的内容**追加**到新AOF，最后改名覆盖现有的AOF

**RBD快照**：把某个时间点的数据以二进制的方式保存到硬盘的一个文件中，而非操作命令，恢复效率更高，但操作频率太高会对redis性能产生影响，频率太低会丢失数据，执行快照的时候可以修改数据，通过写时复制实现（可以定时，可以手动，可以设置触发条件）

**混合持久化**：aof丢失数据少，恢复慢，rbd丢失数据多，恢复快，混合持久化工作在AOF日志重写这一过程，重写子进程先将数据以Rbd的形式写到AOF文件，这个过程中的写操作记录到AOF重写缓冲区，再将这部分增量命令以命令格式写到AOF

**Redis 如何实现服务高可用（redis宕机怎么办）**

1.**主从复制**，读写分离，数据修改只在主服务器进行，收到写命令，发给从服务器。但是，主服务器并不会等到从服务器实际执行完命令后，再把结果返回给客户端，而是主服务器自己在本地执行完命令后，就会向客户端返回结果了。如果从服务器还没有执行主服务器同步过来的命令，主从服务器间的数据就不一致了（异步的）（不是强一致性）

2.**哨兵模式**：监控主从服务器，提供主从节点故障迁移的功能（ping）

3.**切片集群**：数据量大到一台服务器无法缓存，将数据分不到不同服务器上，形成集群，一个集群16384个哈希槽，通过哈希槽处理数据和节点之间的映射关系

补： 主从复制存在集群脑裂问题，可能导致数据丢失

由于网络问题，集群节点之间失去联系。主节点仍能接收请求，但无法像从节点复制，主从数据不同步；哨兵重新组织选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，会清空自己的缓冲区，导致之前客户端写入的数据丢失了。

解决方法：主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的写请求了。

**Redis主从复制**（为什么要用？如何实现？缺点是什么）

K) **Redis过期删除策略**（有什么？redis用的是什么？）

可以给key设置过期时间，将key和过期时间储存到过期字典，查key时先看过期字典是否存在，存在的话再比较当前时间与过期时间

**惰性删除：**不主动删除过期key，每次访问时检查是否过期，若过期则删除，返回null

优点：系统资源占用少 缺点：如果过期的key一直没被访问，就会一直留在库中，对内存不友好

**定期删除：**每隔一段时间取出一定数量的key检查，删除过期的，如果发现过期比例过高会再次执行，如果大量过期，循环时间会很长，可能导致线程卡死，因此除了设置删除执行的频率还要设置一个执行时间上限

优点：减少过期键对空间的占用  缺点：难以确定执行时常和频率，太频繁对cpu不好，太少又和惰性删除一样

redis采用惰性删除和定期删除配合使用，但还是可能会漏掉很多过期key，有引入了内存淘汰策略

K**Redis内存淘汰策略（如何保证redis中都是热点数据）**

**内存淘汰：**允许在资源紧张时，根据一些策略，主动删除一些键值对，以释放空间保证系统稳定性

常见策略：LRU（淘汰最近最久未使用）,LFU（淘汰频率最低）,RANDOM（随机）,TTL（淘汰剩余生存时间最短）,

不淘汰策略，空间不足以容纳新写入的数据时，返回错误，写操作执行失败

补：lru和LFU和RANDOM分全局的和只在设置过期时间的里面选

**Redis 缓存设计？ 如何避免缓存雪崩、缓存击穿、缓存穿透？**

**缓存雪崩**：**大量缓存数据在同一时间过期或者 Redis 故障宕机**，若此时有大量用户请求，都无法在redis处理，全部冲向数据库，数据库压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。
解决方案：**1.将缓存失效时间随机打散**（在原有时间基础上加一个随机值）**2.**服务熔断（暂停访问，直接返回错误）请求限流（只接收少量请求发送到数据库）**3.**构建集群，主节点故障切换到从节点**4.**多级缓存

**缓存击穿**：**热点数据**过期，并且重建比较复杂（缓存可能涉及多张表及运算最后缓存一个结果）

解决方案：**1.互斥锁**，线程1查缓存未命中，查数据库，构建缓存，构建过程中，线程2，3，4也未命中，都去数据库并构建缓存，导致数据库访问压力大，所以用互斥锁和双重检测给构建缓存这个过程加锁，线程1加锁构建缓存，线程234拿不到锁，休眠一会重试，等拿到锁进行二次检测，检测当前缓存是否存在，若存在直接返回
 **2.设置逻辑过期时间，**过期时间不作用于redis，而是从value中判断当前数据过期了（把原来打算存的类和一个过期时间封装成新的类，当作新的val），线程1发现过期，加锁，创建一个新线程异步的更新数据，更新完了再返回，线程234也发现过期了，但获取不到锁，直接返回旧数据

**缓存穿透**：要访问的数据**不在缓存也不在数据库**，没法构建缓存来服务后续请求（可能是误删除或黑客恶意请求不存在的信息）

解决方案：**1.**限制非法请求（api入口处判断请求参数是否合理）**2.**缓存空值，这样就不会继续查数据库（问题：占用空间，缓存大量非法数据，可能造成数据不一致（因为后续可能插入了这个数据），所以要设置ttl）
**3.**使用布隆过滤器快速判读数据是否存在，判断不存在就不用访问数据库（redis本身支持布隆过滤器，存在误判）

其他：多级缓存（本地缓存+分布式缓存）高可用架构（主从复制加集群，避免单点故障）

**Redis如何实现分布式锁**

分布式锁：**分布式系统或集群模式下**，多线程可见并互斥的锁，实现的核心思想是大家都使用一把锁

举例：一人一单问题，需要先根据用户id加锁，拿到锁对象，去数据库找有没有用户id相同且订单id相同，下单，释放锁

问题：分布式环境下，用户多次点击，请求到不同的服务器，每个服务器都能加锁（锁对象不同），就会导致多次下单

为什么用redis：redis本身**被多个客户端共享**，多进程可见，可以用来保存分布式锁，读写性能高，可以应对高并发

原理：SET lock_key unique_value NX PX 10000 

例如:  key是lock:用户id（一人一单），val是uuid+线程id（不同服务器线程id可能相同）

三个要求1.读取锁变量、检查锁变量，设置变量值要以原子操作完成

2.设置过期时间，防止客户端发生异常，无法释放锁

3.解锁就是把锁删除，要保证删锁的客户端就是加锁的客户端，防止误释放，包括两个操作（1.检验，2.删除）需要lua脚本保证原子性

误删：持有锁的线程1阻塞，没有完成任务，没有触发解锁，但到了时间自动释放锁，线程2得到锁；线程1恢复，继续执行，最终会把线程2的锁释放

**分布式id或者说全局唯一id**

需要有一个分布式环境中的唯一标识符，标识各种实体。

如果使用主键自增会有一些问题1.规律性太明显，可能被猜到信息（一天卖了多少单）2.数据量大需要分表，分表后逻辑上仍然是一张表，需要保证id唯一性和递增性。

**UUID**：值是随机的，导致随机插入，页分裂，影响查询性能

**Snowflake算法**：时间戳、数据中心ID、机器ID和序列号

**redis/数据库自增ID:**

**数据库与缓存双写一致性**

改缓存和改数据库一定要同时成功或失败，所以必须**事务操作**

为什么是删除缓存而非更新缓存（防止一直没有使用，但不断发生更新数据库，从而导致不断更新缓存）

一定是先更新数据库再删缓存（删缓存的动作很快，被别的线程打断这一动作的概率小，就不会从缓存读到与数据库不一致的数据）（缓存恰好过期，读旧数据但没来的及写缓存，新线程改了数据库，改缓存，旧线程又切换回来，把旧数据写入缓存）

先删缓存，再更新数据库（可能刚删完缓存还没有更新数据库，此时发生线程切换，新线程访问发现没有数据，去数据库中找，然后用旧数据构建了缓存，导致不一致，发生的概率较大，因为删缓存是一个较快的动作，改数据库是一个较慢的动作）（删缓存，写数据库），（查缓存，读数据库）后者执行快，前者慢

**跳表的实现原理**

**如何实现按照积分降序排序，按照时间升序排序**

**布隆过滤器**

一种数据结构，解决海量数据的存在性问题且容忍轻微误差这一场景，对缓存穿透、海量数据去重这一场景很适合

比list，map，set占用空间更少，效率更高

具体实现：用一个较大的bit数组（位图）保存所有数据，每个位的值只能是1，用多个哈希函数，对指定元素做哈希计算，将对应位数组置为1，判断是否存在时，就重新进行相同的哈希计算，看是否所有位都为1（说存在可能为误判，说不在则一定不在）

补：哈希函数：随机映射函数，常用取余的方式

**和关系型数据库的区别**

**CAP原理**（consistent,available,partation tolerance）

分区发生时，一致性和可用性难以两全



redis事务只能原子性不能一致性，本质上是最后执行一个批处理

命令：setnx key val

​			expire key time

​			ttl key

分布式锁 set kv nx ex 10(因为setnx和过期时间需要同时成功或失败，需要原子操作，只能写在一条语句里)

