[上岸字节了！分享一些 idea (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247527249&idx=1&sn=25c54a80ae53d86528a259840fe6e77b&chksm=f98d2ffbcefaa6edccd86a629f92714b27f8b8525f31bba7dda567f07abaf627bbd4e76f783f&scene=21#wechat_redirect)项目指点

[又被百度捞起来了，能赢吗？ (qq.com)](https://mp.weixin.qq.com/s/1WkJBMMAW1lUZtmWcRQIxQ)合并区间 （排序加双指针），接雨水（动态规划，双指针，单调栈），

[[被字节拷打了！基础还是太重要了... (qq.com)](https://mp.weixin.qq.com/s/EQjV5mBP-0Al1HFFYzOcJA)验证对称二叉树（递归，bfs），岛屿数量（dfs，bfs）

[阿里问的相当基础！ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247527392&idx=1&sn=b1720341b9685328e7f4de0b8bc5c63a&chksm=f98d2f4acefaa65c04857a67686ba00dd7babe54e2364434328ab9eb1dc4219903f3d46a67fa&scene=21#wechat_redirect)数据库的多表联查

[腾讯面试体验倍儿好 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247527244&idx=1&sn=54432eaf69b68b2d8cea97c15b9aa578&chksm=f98d2fe6cefaa6f07a5f3532937e5a3c92de2ed516f08861f220e0b1b2ce5735aa90bc233ba5&scene=21#wechat_redirect)链表判断相交

[一面—京东_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/199c48fb045f467ca899bd7712ae6e8d?sourceSSR=search)

3-8

[快手 效率中心 后端实习 一面_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/581515501239554048?sourceSSR=users)

[momenta 后端实习 一面_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/581516033962287104?sourceSSR=users)

3-13[腾讯云一面 3.11 20.30_牛客网 (nowcoder.com)](https://www.nowcoder.com/feed/main/detail/27a1543b25a047cc86fd48334eafa238)

3-16[腾讯后台开发方向-暑期实习一面_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/596743063414816768)

3-29[OPPO 后端二面，凉凉。。。 (qq.com)](https://mp.weixin.qq.com/s/QrGpIzX7OqLAR5fXp_B0YA)

4-5[字节 飞书办公套件 后端实习 一面_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/581892301245390848?sourceSSR=users)较难

- 大概讲一讲项目
- 讲一下简历里的技术难点







[高并发在简历上如何体现？ (qq.com)](https://mp.weixin.qq.com/s/Y89jLB-ep-cYfv5BG1r5uw)

一个rpc调用耗时很长，怎么解决

讲讲数据库与缓存一致性的四种方案 双更 先删缓存再更数据库 先更数据库 延迟双删

**缓存一致性，**

**缓存穿透击穿，防止超售，redisson，异步秒杀，信息加密**

**整个流程**：初步判断库存充足，加分布式锁，代理对象调用方法，再次判断超售，判断满足一人一单，创建订单

**超售**：乐观锁：cas（compare and swap）包含三个参数（地址，期望值，新值）地址上的值与期望值相等就会改为新值，否则不做任何操作，cas会自旋

1.使用版本号的思想，where stock = vocher.getStock,100个并发只能一个下单

2.改为where stock>0

**reids实现全局唯一id**：时间戳+自增序列号

用于秒杀券订单表：防止被猜，分表后逻辑上是同一张表，雪花算法：时间戳、数据中心ID、机器ID和序列号

模拟了一个分库分表并实现路由

**一人一单：**

补：一般改数据乐观锁，增数据悲观锁

v0：需要先扣减库存，再生成订单，为了保证两张表的操作要么全成功要么全失败，加了**事务**注解，而一人一单过程需要保证一次只能一个线程进入，所以**加锁**

v1：根据优惠券id和用户id查有没有订单，没有，就下单  ——》 问题：并发过来查数据库，都没有订单，导致多次下单，所以需要**加锁** 

v2: 在方法上加锁，粒度太粗，锁的是整个对象，每个线程进来都会被锁住，而非根据用户加锁

v3：用户id加锁  ——>  方法上加了**事务**，先释放锁后提交事务，还是有并发问题

v4：把方法抽取出来，调用之前加锁，也就是在方法外面加锁 	——》使用this调用，而事务需要使用代理对象来操作方法，否则会失效，本质上是使用aop进行方法增强

v5：先加锁，获取代理对象，调用方法  ——》集群并发问题，分布式环境下锁对象不是一个，都能加锁

补：为了应对高并发，启动多个服务（application）对应不同的端口，前端nginx配置反向代理和负载均衡，现在部署了多个tomcat，每个tomcat有自己的jvm，两个jvm中的线程用的是不同的锁对象，都能加上锁（tomcat）

补：tomact是Servlet容器，servlet是javaWeb应用程序的一个模板，接收请求返回响应，

v6：**加分布式锁**，redis setnx实现，防止误删，key用lock：userId，value用uuid+threadId，要设置超时时间

v7:判断锁归属和删除锁是两个动作，需要保证是原子操作，使用lua脚本实现

v8：redis实现分布式锁不可重用，不可重试，主从同步存在延迟可能导致死锁，（主节点有锁，没来的及同步，线程2向从节点请求加锁，请求到了）

改用redission分布式锁

补：红锁：从多个redis节点获得锁，避免单点故障和数据同步延迟，提高可靠性

**补：锁失效问题**，锁是`userId.toString()`，而toString的源码采用的是new String()的方式，哪怕是同一个用户，其id是一样，但toString()得到的也是多个不同对象！也就是多把不同的锁！解决方法：userId.toString().intern()

**补：事务边界问题**

- 业务开始前，先获取锁，再开启事务

- 业务结束后：先提交事务，再释放锁

**补：事务失效问题：**

Spring的事务是基于AOP的方式结合动态代理来实现的。因此事务方法一定要是public的，这样才能便于被Spring做事务的代理和增强。

所以1.事务必须是public 2.非事务方法调用事务方法（隐含this调用）3.事务方法的异常被补货了 或 异常类型不对（Spring的事务管理默认感知的异常类型是`RuntimeException`）

**异步秒杀优化**

订单信息（数目）存在redis里，下过单的用户用set保存，调用lua脚本，redis去进行校验下单条件，得到返回值，判断是否成功，成功则构建订单存入消息队列

判断是否超售，判断是否一人一单---存入消息队列---异步下单

0.收到请求调用redis

1.利用Redis完成库存余量、一人一单判断，完成抢单业务

2.下单业务放入阻塞队列，利用独立线程异步下单（线程池循环处理）

补：防刷限流？自定义注解，redis自增





[SpringBoot下如何实现Redis + Caffeine二级分布式高性能缓存_redis+caffeine-CSDN博客](https://blog.csdn.net/hxx688/article/details/120601972)多级缓存

### 令牌桶限流算法

1.对什么限流？接口、连接 2.阈值，达到多少限制访问3.触发限流后的行为

系统以恒定速率向令牌桶添加令牌，服务端收到请求，先从桶里去拿令牌，因此流量低时可以缓存一定数量的令牌，因此它可以处理流量的突增

Sentinel限流：创建一个拦截器，拦所有请求，限制每秒2000个，超出匀速排队，拦ip，每秒最多50个，每分钟最多1000个超出拒绝

通过注解指定资源、

补：限流的三个维度：按请求路径，按ip，按用户和

### 多级缓存

- 请求到达Nginx后，优先读取Nginx本地缓存
- 如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）
- 如果Redis查询未命中，则查询Tomcat
- 请求进入Tomcat后，优先查询JVM进程缓存
- 如果JVM进程缓存未命中，则查询数据库

调redis涉及到网络调用 补：程序跑在jvm里，一般一个jvm就是一个进程

问题：进程空间（jvm）大小有限，不支持大数据存储 --》只存储最热的数据（热门商品）

​			重启项目会丢失数据  --》项目重启时重新拉取热点数据

​			分布式场景下，系统间数据不一致--》根据id做负载均衡，如果分布式储存的是相同的数据怎么保证一致性？			

​			和远程缓存间可能有数据不一致  --》例如浏览量，远程缓存更新，本地缓存一直不更新

一致性问题：设置一个较短的过期时间，过期重新重远程缓存拉取，保证数据最终一致性，一直到热点数据非热点，到时候直接访问远程缓存

如何判断热数据：缓存热商品，如疫情中的口罩

技术服务（通过mq调用一个计数服务）/滑动窗口（开源热点探测框架jdhotkey京东）

伪代码

```
boolean exist = false
if(是热点数据){
​	//读本地缓存
​	if(本地缓存存在){
​		return 数据
​	}
	exist = true;
}
	//不是热点数据
	//查数据
	redis.get()
	//是热点数据但缓存不存在
	if(exist){
		//缓存到本地,并设置过期时间
	}
	return 数据
```

![image-20240222142206076](C:\Users\16776\AppData\Roaming\Typora\typora-user-images\image-20240222142206076.png)


springCache适合缓存控制没有那么细致的场景，如门户首页，偏静态展示页面，榜单等等

分布式服务可以用 redis 的 pub/sub 实现分布式多级缓存

补：缓存预热，利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中，利用InitializingBean接口来实现，在对象被Spring创建并且成员变量全部注入后执行。

补：为减轻Tomcat压力的多级缓存结构，先查浏览器缓存，然后nginx本地，然后redis，然后tomact，最后再数据库

## 场景题

**高并发登录如何实现**

1.缓存，用户信息存到redis，token当key去缓存查用户信息，减轻数据库负担，或者用jwt的形式，把用户信息编码到token里，然后解密，但是可能不安全
2.反向代理和负载均衡，确保请求分散到不同的服务器，为了保证缓存命中，根据请求做负载均衡，保证相同请求打到同一服务器上
3.限流，限制登录次数，如多次密码不正确需要输验证码
4.异步处理
5.分布式会话

**密码输入5次以上锁定怎么实现**

一个计数器，一个账户状态的字段，有加锁就得有解锁，超时解锁或邮件解锁，

如何学习一门新技术
1.面到点 2.重要性排序 3. 画思维导图 4.复习



优化思路：多级缓存（caffeine），冷热数据隔离（数据归档）

**优化过去的项目，你如何优化**

### rpc项目

**开发过程**

1.整体结构，接口定义（框架暴露的，注册中心的）

2.通信与序列化，netty异步传输（请求id+CompletableFuture构建一个map），背压机制（信号量）控制客户端请求速率

3.客户端：生成桩，代理模式，生成类，编译，加载，不用rpc生成桩的方法不一样

4.服务端：找到服务提供者，利用 Java 反射机制调用服务的对应方法

补：序列化：专用序列化：你要为每一种类型的数据专门编写序列化和反序列化方法。一般的 RPC 框架采用的都是通用的序列化实现，比如 gRPC 采用的是 Protobuf 序列化实现，Dubbo 支持 hession2 等好几种序列化实现

是一个优化点，影响响应速度，吞吐量

补：生成桩：参考Dubbo部分源码，实现了自定义的SPI机制，目前仅支持根据接口类型加载配置文件中的所有具体的扩展实现类，并且可以根据指定的key获取特定的实现类，具体实现类逻辑在

**RPC的流程**

调用远程服务器的方法像调用自己的一样

服务端启动服务，完成服务注册（包含两部分 1.接收到请求后要能找到对应的实现类 2. 要把ip地址和服务名注册到注册中心）

客户端调用注册中心接口的方法，查询服务地址，服务中心从服务列表中根据据负载均衡选择一个服务地址

然后调用rpc框架的方法，拿到桩，然后把参数传给桩，桩发送请求，请求包含方法参数、方法名等

io过程涉及序列化成字节流

服务端调用对应的服务实现类，得到结果，返回给rpc框架，再返回给客户端

在接口定义上，需要使用`@Service`注解标识服务提供者的服务接口，使用`@Reference`注解标识消费者的引用接口。这些注解用于标识Dubbo的服务提供者和消费者，以便Dubbo框架能够识别并管理这些服务。

**单例模式，责任链模式，自定义注解**，建造者模式

注册中心得是单例：减少资源消耗，保证一致性

调用远程服务通过代理模式，

处理请求通过责任链模式

注册中心redis/zk，储存ip地址等，本地再有一级缓存，本地无法命中时从远程拉

客户端服务发现（找对应的实现类）策略模式+命令注册机制，省略ifelse

**你的rpc框架接口用什么做约定，知道工业界是怎么做的吗**

在接口定义上，需要使用`@Service`注解标识服务提供者的服务接口，使用`@Reference`注解标识消费者的引用接口。这些注解用于标识Dubbo的服务提供者和消费者，以便Dubbo框架能够识别并管理这些服务。

自定义的通信协议及编解码器（rpcMessage）（魔术+版本号+序列化算法+消息类型+状态类型+序列号+消息长度）

编解码用于解析请求头中的信息，检验魔术，版本号等，检验消息类型**（心跳还是回复）**，拿到序列化算法，根据消息类型，完成消息体的转化（rpcRequest）

```
工厂创建代理，代理（生成字节码，类加载器加载，这个时候他的方法实际上就已经是远端过程调用了，创建对象，调用方法）invoke，RemoteMethodCall封装rpcmessage，服务发现负载均衡得到服务地址，封装metada，rpcClient使用netty异步发送请求，
```

启动 10000 个线程同时访问 sayHello 接口，总共进行 3 轮测试

**ZK 集群的读写吞吐量不高**所以需要缓存

**序列化和反序列化以及编解码有什么区别**

编解码用于netty发送，序列化反序列化用于接收方和发送方能够理解并还原信息

服务发现--生成桩--序列化--接收--处理

TPS（Transactions Per Second，每秒事务数）

**幂等性怎么做？**

客户端做接口幂等性，服务端setnx加锁

rpc幂等不太重要，像dubbo就没有提供幂等

**常用的RPC框架和他们的区别**

grpc：基于http2

dubbo：易于集成spring

加密算法，压缩算法

```
谈谈分布式
谈谈分布式一致性算法，tcc，raft
分布式事务一致性问题，介绍一下算法
分布式锁
项目中mysql和redis的用处
项目难点，怎么解决
怎么实现高并发
怎么实现缓存和数据库的数据一致性
redis集群怎么实现,redis主从复制怎么实现，具体的名词和实现
```





