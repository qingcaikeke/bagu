**运算器、控制器、存储器、输入设备、输出设备**

cpu：**寄存器、控制单元和逻辑运算单元** 

32位与64位：一次运算四字节还是八字节 如果八位只能算255以内的加减乘除。

- *通用寄存器*，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。

- *程序计数器*，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。

- *指令寄存器*，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。

  总线是用于 CPU 和内存以及其他设备之间的通信

  - 首先要通过「地址总线」来指定内存的地址；
  - 然后通过「控制总线」控制是读或写命令；
  - 最后通过「数据总线」来传输数据

如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了

## 线路位宽与 CPU 位宽

**如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来**。

这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。

为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址

线路的位宽最好一次就能访问到所有的内存地址，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线

通常来说 64 位 CPU 的地址总线是 48 位，而 32 位 CPU 的地址总线是 32 位，所以 64 位 CPU 可以**寻址更大的物理内存空间**。

64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是**如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令**；（区分硬件位宽和软件位宽）



CPU 的硬件参数都会有 `GHz` 这个参数，比如一个 1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒会产生 1G 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期。一条指令的执行不止一个时钟周期

cpu执行程序：通过程序计数器找到下一条指令的位置，地址总线找到，控制总线传递读命令，通过数据总线传回来，存到指令寄存器，

程序计数器的值自增（32位cpu指令是4字节，值加4）



储存器层次结构：寄存器，cpu三级缓存，内存，硬盘

内存映射到cpu cache：一次储存一小块而非一个字节，**cache 索引，组标记，偏移量**

\- 索引 + 组标记 -> 定位具体的缓存行
\- 偏移量 -> 定位缓存行内的具体字节

当多个内存地址映射到同一个缓存索引时,就发生冲突。组标记用于区分这种冲突情况

 L1缓存- 容量:32KB~64KB
\- 缓存行大小:64字节
\- 所以L1缓存大约有512~1024个缓存行



如何写出让cpu跑的更快的代码：提高缓存命中率 1.提高指令缓存命中2.提高数据缓存命中率3.同一线程不要来回切换cpu执行

cpu缓存一致性：1.写传播2.事务的串行性

实现：MESI协议（）内置锁机制

- *Modified*，已修改	处于这个状态时cpu缓存中的内容与内存中的不一样
- *Exclusive*，独占
- *Shared*，共享
- *Invalidated*，已失效
- 当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的；
- 然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的；
- 当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「**无效**」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了。（**先广播，把其他的标记成无效，再修改自己的**）
- 如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。
- 如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「替换」，发现 Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。



伪共享：多个线程读写同一个cache line中的不同变量，会导致频繁的内存读写，也就是缓存失效

那么对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个 Cache Line 中，避免的方式一般有 Cache Line 大小字节对齐，以及字节填充等方法。中断处理程序的上部分和下半部可以理解为：



- **上半部直接处理硬件请求，也就是硬中断**，主要是负责耗时短的工作，特点是快速执行；硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序

- **下半部是由内核触发，也就说软中断**，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；

  软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程

  中断之所以是异步的,是因为它不需要当前执行线程的同意或协作,可以强制打断当前线程执行流程。这点不同于同步(需要协作)和异步(需要等待/通知)。

  所以中断对当前线程来说是非协作的、强制的、不可预测的。这就是中断的异步性。


负数补码表示：取反加一

小数表示：乘二取整  0.625 -> 101 ->1 * 2^-1+0 * 2^-2+1 * 2^-3 =0.5+0.125 

0.1二进制无限循环 1.乘二取整表示成二进制2.科学计数法3.得到指数位和尾数位4.表示成浮点数

 8.625->1000.101:十进制转二进制

二进制转十进制

所以通常将 `1000.101` 这种二进制数，规格化表示成 `1.000101 x 2^3`，其中，最为关键的是 000101 和 3 这两个东西，它就可以包含了这个二进制小数的所有信息

- `000101` 称为**尾数**，即小数点后面的数字；
- `3` 称为**指数**，指定了小数点在数据中的位置

小数浮点数表示：符号位 + 指数位 + 尾数位    浮点数转10进制：小数部分转成十进制（1+尾数）*2^(指数减偏移量)

小数点右移相当于乘2的n次方

## 内核

如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，**让内核作为应用连接硬件设备的桥梁**

现代操作系统，内核一般会提供 4 个基本能力：

- 管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；
- 管理内存，决定内存的分配和回收，也就是内存管理的能力；
- 管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；内核可以与计算机硬件交互通讯
- 提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，系统调用函数时内核对外暴漏的一个接口。

应用程序想要读磁盘上的数据，要通过系统调用函数（使用read（）函数），进入内核态，触发第一次中断，告诉cpu停止当前活动，内核执行真正地系统调用函数（sys_read），进行读磁盘上的数据，到内核缓冲区，这个时候cpu执行权就切换到了内核，然后内核缓冲区拷贝到应用缓冲区，完成后，内核产生一个中断，cpu继续之前的任务，执行权重新回到用户态

宏内核：有多个模块，集成在内核里，如驱动，效率高，不易扩展维护（函数耦合，不能独立编译，可以访问全部内存可能有冲突，一旦崩溃系统不可用）

微内核：除了进程内存等，其他模块交由用户态管理，与内核分开加载，效率低，好维护（鸿蒙）



同步: 执行操作时需要等待操作完成,才能进行后续操作。异步: 操作请求发出后,不需要等待操作完成,直接进行后续操作。

同步需要等待操作完成,异步不等待直接继续,典型通过回调函数异步通知操作完成。

异步可以大大提高程序响应性,避免阻塞。

- 代码段，包括二进制可执行代码；
- 数据段，包括已初始化的静态常量和全局变量；
- BSS 段，包括未初始化的静态变量和全局变量；
- 堆段，包括动态分配的内存，从低地址开始向上增长；（数组扩容）
- 文件映射段，包括动态库、共享内存等；
- 栈段，包括局部变量和函数调用的上下文等



代码编译成二进制文件，运行该文件，加载到内存，cpu执行，就成了一个进程（运行中的程序）

运行态到就绪态：调度程序选择了另一个程序，时间片用完

运行到阻塞：请求某个事件，必须等待 		**一旦被阻塞等待，它只能由另一个进程唤醒**

阻塞到挂起：不希望阻塞占用物理内存，**描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态**

致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：（分就绪挂起和阻塞挂起）

- 通过 sleep 让进程间歇性挂起，其工作原理是设置一个定时器，到期后唤醒进程。
- 用户希望挂起一个程序的执行，比如在 Linux 中用 `Ctrl+Z` 挂起进程；

**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**

为什么用线程：单进程资源利用率低，（如视频播放 1.读文件2.解压缩3.播放）会卡顿

​						多进程通信不变，没法共享地址空间

**线程是进程当中的一条执行流程。**

同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。

线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。

进程崩溃：收到系统的信号（如kill），然后进程可以自己定义信号处理函数







**每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。**

管道：它的功能是将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入，**管道传输数据是单向的**

只有当管道里的数据被读完后，命令才可以正常退出。区分匿名管道与命名管道

管道只能单向传输，传输无格式的流，匿名管道只能在父子进程间通信，通过文件描述符（父子的一样），shell是创建了两个他的子进程，然后让这两个子进程通信。匿名管道只存在于内存不存在于文件系统

命名管道创建了一个系统管道文件，线程访问这个文件实现通信。管道效率低，a把消息放入后，必须等b读入才能返回



**消息队列是保存在内核中的消息链表 **每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。

**消息队列不适合比较大数据的传输**

**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**

消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。



**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。多个进程共享同一块内存区域

为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，保证同步。正好，**信号量**就实现了这一保护机制。



**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。

信号初始化为 `1`，就代表着是**互斥信号量**   p操作减一，v操作加一

信号初始化为 `0`，就代表着是**同步信号量**
信号量也同样可以在线程间实现互斥与同步：

- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
- 同步的方式，可保证线程 A 应在线程 B 之前执行；



**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。**

内核也可以利用信号来通知用户空间的进程发生了哪些系统事件

信号与信号量完全无关，是进程间通信机制中**唯一的异步通信机制**，因为它们允许进程在不知道何时会接收到信号的情况下，随时接收并处理信号。无需等待， 进程可以继续执行其他任务，不需要等待信号的到来。当信号发送时，操作系统会中断接收信号的进程，使其处理信号，而不需要等待发送信号的进程的响应。2.随时发送。

**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、（自定义信号处理机制）3. 忽略信号**	（）



socke分tcp协议还是udp协议

所以，监听的 socket 和真正用来传送数据的 socket，是「**两个**」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。

当一个客户端请求连接时，监听socket会接受该请求并创建一个新的已完成连接socket用于与客户端进行通信

1. **Bind（绑定）：** 在服务器端，首先需要使用`bind()`函数将一个socket与特定的IP地址和端口号绑定。这告诉操作系统，当有数据包到达特定的IP地址和端口时，交给这个socket处理。
2. **Listen（监听）：** 绑定完成后，服务器调用`listen()`函数开始监听来自客户端的连接请求。这时，socket进入监听状态，等待客户端的连接请求。
3. **Accept（接受连接）：** 当有客户端连接请求到达时，`accept()`函数被调用。这个函数会阻塞程序，直到有客户端请求连接。一旦有连接请求，`accept()`函数返回一个新的已完成连接socket，用于服务器与客户端之间的实际数据传输。
4. **Connect（连接）：** 在客户端，调用`connect()`函数试图连接到服务器。这个函数指定服务器的IP地址和端口号。如果连接成功，客户端就可以通过这个socket与服务器进行通信。



文件系统：永久储存 内存：临时储存，断电丢失

- 

























