### java，C ++， Python 哪一个更快？

go参数在前返回值类型在

c++（go）编译型，源码直接全部编译成机器码，生成可执行文件，跨平台差，同样的源码不同平台理解的意思不一样

python解释型，一句一句的解释成机器码，每次执行程序都需要一边转换一边执行

java解释型+编译型，先通过javac编译成class字节码文件，交由jvm，由里面的解释器解释成字节码文件

### 堆内存和栈内存有什么区别

栈内存自动分配释放，栈空间连续，访问速度更快，函数参数局部变量返回值地址 。一般大小固定，生命周期一般与函数执行周期相同

堆内存手动分配，动态分配malloc，new，储存空间较大，取决预分配，分配释放需要更多时间资源，生命周期不限，需要手动释放

栈内存主要用于存储函数调用时的局部数据，它具有**快速的访问速度和自动管理**的特点。

而堆内存则用于存储程序中的**动态分配**的数据，具有灵活性但需要**手动管理**内存的生命周期。

### 数组怎么动态扩容？

开始的时候创建一个空数组，添加一个元素的时候扩容为最小值。添加元素空间不足，自动扩容，创建一个新的数组，容量为原来的1.5倍，然后把原来的拷进去。如果容量已经很大了，可能1.25倍

### 常规的多线程开发需要注意哪一些问题？

资源竞争（线程安全），死锁，饥饿，线程通信（wait，notify）线程池（减少频繁创建销毁线程的开销）

（核心线程数，最大线程数，任务队列，存活时间，拒绝策略）

### 读写共享变量会遇到什么问题？

并发访问

1. **竞态条件（Race Condition）：**
   - 当两个或多个线程同时访问共享变量，并试图对它进行修改时，由于操作的不确定性和交错顺序，可能导致意外的结果。例如，两个线程同时读取变量的值，然后基于这个值进行修改，这样的操作可能导致不一致的结果。
2. **数据不一致性（Inconsistency）：**（多个线程++）（侧重结果不正确）
   - 多个线程同时读写共享变量，由于缺乏同步机制，变量的值可能处于不一致的状态。例如，一个线程正在对变量进行更新，而另一个线程正在读取这个变量的值，读取到的可能是更新前的值，而不是更新后的值。
3. **可见性问题（Visibility Problem）：（侧重读的值没有被及时更新）**
   - 当一个线程修改了共享变量的值，其他线程可能无法立即看到这个修改。这是因为不同线程的操作可能在不同的CPU缓存中进行，导致一个线程对变量的修改对其他线程不可见。这种情况下，需要使用同步机制确保变量的可见性。

### 接口和抽象类有什么共同点和区别？

- 都不能被实例化。都可以包含抽象方法。抽象类（模板设计）接口（行为规范）

接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。

一个类只能继承一个类，但是可以实现多个接口。

接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

**深拷贝和浅拷贝区别了解吗？什么是引用拷贝？**

引用拷贝就是两个不同的引用指向同一个对象，深浅都会在堆中创建新对象，但如果对象的属性是引用的话，浅直接拷贝这个引用

### Object 类的常见方法有哪些？





**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。先创建一个“ab”，在创建一个ab，二者引用的是一个对象

**Exception 和 Error 有什么区别？**

程序本身可以处理，可以自定义处理方法，然后捕获并处理。受检查异常必须处理才能通过编译

语法糖：对功能没有影响，方便使用，最终还是会转换为基础语法结构（for each）

反射（运行期间拿到一个对象的所有信息），注解

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理

注解解析：**编译期直接扫描**（override），**编译期直接扫描（component）**

**序列化?什么是反序列化?**

对象到二进制，二进制到对象（目的：传输，存储）

数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流

 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可

**sleep() 方法和 wait() 方法对比**

是否释放锁，用途，notify，使用对象（thread，object类的锁对象（因为需要释放锁））

`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，**这个变量是共享且不稳定的**，每次使用它都到主存中进行读取（本地内存：cpu三级，主存：内存）（易变的，不稳定的）

​	**`volatile` 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。**

`synchronized` 关键字两者都能保证

一个线程修改了volatile变量,其它线程可以立即看到修改后的值

**编译器和处理器为了优化,可能会对指令进行重排。volatile可以禁止对变量访问和设置的指令重排。**

```HTML
private Lock lock = new ReentrantLock();
lock.lock();
try {
   // 需要同步的操作
} finally {
    lock.unlock();
}
```

**任务分为IO密集型和计算密集型两种**

1. 计算密集型：吃CPU，比如音视频处理、图像处理、数学计算等，一般是设置corePoolSize为CPU的核数 +1 (空余线程)，可以让每个线程都利用好CPU的每个核，而且线程之间不用频繁切换（减少打架、减少线程切换开销）

1. IO密集型：吃带宽/内存/硬盘的读写资源，corePoolSize可以设置大一点，一般经验值是 2n 左右，但是建议以 IO 的能力为主。

DTO，PO，VO

- DTO：数据传输对象，在客户端与服务端间传递数据，例如微服务之间的请求参数和返回值、前端提交的表单
- PO：持久层对象，与数据库表一一对应，作为查询数据库时的返回值
- VO：视图对象，返回给前端用于封装页面展示的数据

**CAS底层怎么实现**

读内存位置的值，比较，如果与预期相等，则更关心，需要保证比较和更新是原子操作

底层靠的是硬件，依靠本地方法调用，有一个volitale变量，带着预期值和想修改的值去和这个变量比，一样则修改，然后返回旧值

缺点：cas会自旋，因为执行的是do while，开销大 2.会导致aba问题

**并发测试**



**es倒排索引**

首先进行文档分词，然后构建词汇到文档id的映射，key是单词，val是出现过这个单词的文档id

**你的项目用到了哪些微服务组件？**

- **Eureka**：服务注册与发现组件，用于实现微服务架构中的服务注册和发现。
- **Ribbon**：负载均衡组件，用于在客户端实现负载均衡，提高系统的可用性和性能。
- **Feign**：声明式的 HTTP 客户端组件，简化了服务之间的调用和通信。
- **Hystrix**：熔断器组件，用于防止微服务间的故障蔓延，提高系统的容错能力。
- **Zuul**：API 网关组件，用于统一访问入口、路由请求和过滤请求，提高系统的安全性和可维护性。
- **Config**：配置中心组件，用于集中管理微服务的配置信息，实现配置的动态刷新。

**负载均衡算法**

简单轮询，加权轮询，简单随机，加权随机，一致性哈希，最小活跃数（统计每台服务器上当前正在处理的请求数）

一直均衡给一个服务器：客户端 ip、或请求参数通过哈希算法，能保证同一个客户端或相同参数的请求每次都使用同一台服务器。

**介绍下熔断**

类似保险丝，某个微服务不可用或者响应时间太长时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。

服务A调用服务，服务B调用服务c，某一时间链路上对服务C的调用响应时间过长或者服务C不可用，随着时间的增长，对服务C的调用也越来越多，然后服务C崩溃了，但是链路调用还在，对服务B的调用也在持续增多，然后服务B崩溃，随之A也崩溃，导致雪崩效应。

Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。

**介绍下降级**

保证核心功能可用，一些非核心的接口和数据的请求不处理或简单处理，以释放资源
