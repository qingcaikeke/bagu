### 点赞系统

[day06-点赞系统 - 飞书云文档 (feishu.cn)](https://b11et3un53m.feishu.cn/wiki/wikcnYCUX9L5acU0mSpVHT4gPBg)

**点赞优化**（吞吐量高，能接受数据不一致）

读写都落redis，异步线程定期刷mysql固化

开发通用性，独立性的点赞系统，使用合并写加异步写

点赞记录表（liked_record）‘主键id’ ‘用户id’ ‘业务id’ ‘业务类型’ ‘创建时间’ （点赞系统维护）

点赞统计表（liked_stat） ‘主键id’ ‘点赞总数’ ‘业务id’ ‘业务类型’ ‘创建时间’	（业务）

 "高效处理点赞请求"、"实时更新点赞统计

功能

1.点赞、取消

2.某一项目的点赞总数

3.批量查询用户点过赞的项目，传过来一堆业务id，去数据库找对应的record



点赞系统接收请求 -》修改点赞记录 -》更新点赞数 -》mq通知对应的业务方 -》 业务方修改数据库

利用TOPIC类型的交换机，结合不同的RoutingKey，可以实现通知对象的变化。

高并发优化：用不同业务类型做隔离，某业务数据量过大还可以分片（为什么数据库要保存一份点赞数量，对应业务经常查，具体谁点赞详情页）

redis缓存+**持久化机制**保证数据安全，用定时任务定期的将点赞数量同步给业务方，持久化到数据库

点赞记录：用了set结构，key是业务类型+业务id，值是点赞过的用户id，同时**SET结构会在头信息中保存元素数量**，o（1）时间拿到总数，针对大v bigKEy的问题做hash分片

新问题：刷新页面时会出现大量新业务，页面需要判断当前用户有没有对某些业务点赞，为减少带宽消耗，使用redis的Pipeline管道方式，一次请求实现多个业务点赞状态的判断了（数据库批量查改redis批量查）

如果每次数量更新都用mq消耗也很大，所以用定时任务+zet（zet储存点赞数变化的业务及对应的点赞总数，可以理解为待持久化的点赞任务对队列），定时任务开启时，只需要从ZSET中获取并移除数据，然后发送MQ给业务方，并持久化到数据库即可。

zset底层哈希加跳表（val是业务id分值是点赞总数），不用list是因为他没有唯一性，每次更新都需要储存一次，然后接收方需要多次改数据库，不用map是因为他不安全，因为涉及到读点赞数、移除、发mq，**查询并移除**必须原子操作，否则可能读完了，没删，又被改了，然后删，这样就白改了

补：如果redis存的点赞记录非常大怎么办？1.定期将点赞记录持久化到数据库 2.历史点赞记录从redis中移除，只保留数据库中的部分 3.某个记录被点赞时，优先去Redis查询并判断，如果Redis中不存在，再去查询数据库数据并缓存到Redis

补：高并发写操作常见的优化手段有：1.优化sql 2.变同步写为异步写 3. 合并写请求



### 算法题


给你一个数，求该数由最少的平方数相加，不可以用动态规划

### 其他

1bite（字节）是8bit（二进制）1kb=1024bite 1mb=1024kb

本地缓存：Guava，Caffeine，Ehcache或者自己简单的使用HashMap实现

分布式缓存：Redis，Memcached等。

Canal：监听mysql的binLog，实现缓存和数据库的数据同步（缓存数据同步的常见方式：设置有效期，同步双写（改数据库同时直接该缓存），异步通知（改数据库后异步通知改缓存，Canal））

wireshark：抓包用的

mogodb：文档型数据库，类json储存

elasticsearch：分词，倒排索引，可以当数据库用

openrestry：通过lua扩展nginx实现可伸缩的web平台

在做研发工具链				

保序性，处理重复消息，可靠性，阻塞读取，是否支持消费者组

消息队列;

udp有校验和？ 有



力扣周赛
kaggle
阿里天池
华为软件精英



spring-boot-starter：一组依赖的集成，快速启动某一项目

closable：实现该接口：意味着该类持有一些资源，比如网络连接或文件句柄，需要在不再需要时释放这些资源。

docker -v 主机路径：容器路径(volume) 挂载

netfilx：网飞，电影厂，程序开发（hystrix）

webSocket：双工，长连接，弹幕，体育赛事实时更新（没刷新但页面变化）

URI（identifier）包括URL（locator）和URN（name，如uuid）

为什么要用网关：1.转发，路由，前端对接网关，网关对接后端，2.负载均衡（一个服务有多个实例）3.认证、授权、限流









