**链表跟数组有哪一些区别？**

增删改查的复杂度，数组内存地址连续，cpu缓存命中率高；应用场景数组适合静态大小、频繁访问元素，链表一般频繁插入删除

**动态规划算法**：将问题拆解成相互重叠的子问题，避免重复计算，需要状态转移方程和记忆化储存

**背包问题**（力扣416）

**01背包** 外层宝物，内层倒序容量，`dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) `

需要注意的是，为了防止上一层循环的`dp[0,...,j-1]`被覆盖，循环的时候 j 只能**逆向枚举**（空间优化前没有这个限制），伪代码为：

**完全背包**：宝物可以选多次`dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) // j >= w[i]`

优化后不同点在于这里的 j 只能**正向枚举**而01背包只能逆向枚举





对key进行哈希运算得到索引，将下标存到对应索引，但是会产生哈希冲突（一个索引位置存放多个元素），通过链表解决，后又优化成红黑树。

key是存在数组里，所以保证一下子就能找到

二叉查找树（二叉搜索树）中序遍历递增（logn ~ n）

linkedlist也可以通过下标查找但是不高效，因为他内部维护了一个size，每次根据访问的下标，看从后往前找还是从前往后找，保证o(n/2)

**并查集**：一种数据结构，分三部分（并union，查find），用于处理不相交集合的合并问题

或者说能维护两个操作（快速确认元素属于哪个集合（查根节点），能将两个集合进行合并）的数据结构叫并查集

1.用一个数组储存每个元素的父节点，开始时每个元素的父节点是自己

2.一个递归函数find，去找i的祖先，并进行压缩

3.合并，找到i的祖先，再找j的祖先，让i的祖先指向j的祖先

一般使用树表示，合并时，把高度小的树合并到高度大的树上面

**图**：顶点，边，度（入度，出度），有向图（关注关系），无向图（同学关系）无权图，带权图（关系强弱，城市距离）

邻接表储存，邻接矩阵储存

拓扑排序：给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：

对于图 G中的任意一条有向边 (u,v)，u 在排列中都出现在 v 的前面，那么称该排列是图 G 的拓扑排序

可以用于检测是否有环，若图中存在环，一定不存在拓扑排序，x2在x1前面，x1也要在x2前面

求出一种拓扑排序方法的最优时间复杂度为 O(n+m)，m个节点，n条边

补：求无向图是否有环用并查集

**堆**：定义：大根堆（每一节点的值大于等于所有子节点）最小堆，方便获取**最大最小值**，可以实现**优先队列**

堆是一颗完全二叉树（最后一层从左往右排），用数组储存（第i个节点的左节点2*i+1，右节点2*i+2）

堆的构建：乱序数组-》堆，可以自上而下构建（o(nlogn)，将新元素放到堆的最后一位，然后进行上滤），

或自下而上构建（o(n)，直接调整堆，从倒数第二行开始，比较当前元素和左右子节点，看是否需要调整，调整子树会发生变化，需要递归的调整）

堆的插入：先插到最后，然后交换第一个和最后一个，然后堆化log(n)

堆的删除：把最后一个位置的元素填到删除的位置，然后从替换的位置开始堆化

删除：把最后一个元素拿到堆顶，和左右比，和大的交换

**topK问题**

可以通过最小堆实现求最大的topK，先用k个元素建堆，然后遍历剩下的，如果元素大于堆顶，就交换，然后重新调整堆。

（相当于每次从k个中最小的交换）

**合并K个有序数组**，

最小堆，复杂度nlog(k)，建堆时间o(k)，之后每插入一个元素替换堆顶并重构的时间为logK，n个元素，所以是nlogk

两两归并，复杂度nlog(k),每次合并都需要扫所有的元素，归并需要log(k)次，但是空间复杂度不如堆好

**前缀和**

需要多次求数组中从l到r的元素之和，通过计算前缀和即前i个元素的和（包括当前元素）存在数组里实现

二维前缀和，方阵中左上的元素之和

例：算一个人的成绩在班级中的百分比：开若干个桶，桶里记比当前分数高的人数

**随机存取和顺序存取**（针对数据结构而言）

顺序存取：磁盘，链表，读写所需的时间与元素位置有关

随机存取：数组，存取所需的时间与元素位置无关

**顺序存储和随机存储**（针对储存介质而言）

顺序存储：一连串储存空间，可以实现随机存取，不便于数据插入删除，一次需要一整块储存单元，会产生内存碎片

随机存储：修改方便，能利用碎片

**怎么在数组每个元素大小不一样的情况下保证随机存取**

使用间接索引，数组存索引，索引指向实际数据，然后随机取得话就随机取一个索引，再拿到数据

**怎么优化链表查询速度**

通过空间换时间的方法：双向链表，快表，map（key是元素，val是位置）

**avl树**

通过左旋右旋保持平衡，有个平衡因子（右高减左高），值为0，1，-1，平衡因子大于1旋转

**两个栈如何实现队列**

一个push栈，一个pop栈，入的时候入push，出的时候看pop中有没有，有直接弹栈顶，没有把push栈的元素依次入到pop栈，然后弹栈顶
